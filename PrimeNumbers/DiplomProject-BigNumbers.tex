\paragraph{} Существует довольно эффективный способ убедиться, что заданное число является составным, не разлагая это число на множители. 
Согласно малой теореме Ферма, если число \textit{n} простое, то для любого целого \textit{a}, не делящегося на \textit{n}, выполняется сравнение
\begin{equation}
 \textit{{$a^{ n-1} \equiv 1 (mod n)$}}.
\end{equation}
Если же при каком-то {$a$} это сравнение нарушается, можно утверждать, что {$n$} - составное. Вопрос только в том, как найти для составного {$n$}
целое число {$a$}, не удовлетворяющее (2.1.1). Можно, например, пытаться найти необходимое число {$a$}, испытывая все целые числа подряд, 
начиная с {$2$}. Или попробовать выбирать эти числа случайным образом на отрезке {$1 < a < n$}.

  К сожалению, такой подход не всегда даёт то, что хотелось бы. Имеются составные числа {$n$}, обладающие свойством (2.1.1) для любого целого
{$a$} с условием {$(a, n) = 1$}. Такие числа называются числами Кармайкла. Рассмотрим, например, число {$561 = 3 \cdot 11 \cdot 17$}. 
Так как 560 делится на каждое из чисел 2, 10, 16, то с помощью малой теоремы Ферма легко проверить, что 561 есть число Кармайкла. 
Можно доказать, что любое из чисел Кармайкла имеет вид {$n = p_{1} \dots p_{r}, r \geq 3$}, 
где все простые {$p_{i}$} различны, причем {$n - 1$} делится на каждую разность {$p_{i} - 1$}. 
Лишь недавно, была решена проблема о бесконечности множества таких чисел.

  В 1976 г. Миллер предложил заменить проверку (2.1.1) проверкой несколько иного условия. Если {$n$} - простое число, 
{$n - 1 = 2^{ s} t$}, где {$t$} нечётно, то согласно малой теореме Ферма для каждого {$a$} с 
условием {$(a, n) = 1$} хотя бы одна из скобок в произведении
\begin{equation}
 \textit{{$(a^{ t} - 1)(a^{ t} + 1)(a^{ 2 t} + 1) \dots (a^{ 2^{ s - 1}t} + 1) = a^{ n - 1} - 1$}}
\end{equation}
делится на \textit{n}. Обращение этого свойства можно использовать, чтобы отличать составные числа от простых.

Пусть {$n$} - нечётное составное число, {$n - 1 = 2^{s} t$}, где {$t$} нечётно. Назовем целое число {$a$},
{$1 < a < n$}, «хорошим» для {$n$}, если нарушается одно из двух условий: 
\begin{enumerate}
 \item {$n$} не делится на {$a$};
 \item {$a^{ t} \equiv 1 (mod \: n)$} или существует целое \textit{k}, {$0 \leq k \leq s$}, такое, что
  \begin{equation}
      \textit{{$a^{ 2^{ k} t} \equiv -1 (mod \: n)$}}
  \end{equation}

\end{enumerate}
Из сказанного ранее следует, что для простого числа {$n$} не существует хороших чисел {$a$}. Если же {$n$} составное число, 
то, как доказал Рабин, их существует не менее {$\dfrac{3}{4}(n - 1)$}.


\section{Проверка большого числа на простоту}

\paragraph{} Перед описанием некоторых алгоритмов и тестов на простоту чисел введем определения и утверждения

  \begin{definition}    
  
      Пусть {$n \in N$} нечетное число и {$n - 1 = 2^{ s} t$}, {$t$} – нечетное,
    число {$a \in N$}, такое, что {$0 < a < n$}, называется свидетелем 
    простоты числа {$n$}, если выполнены 2 условия:

    \begin{enumerate}
      \item {$(a, n) = 1$}
      \item Справедливо хотя бы одно из сравнений {$a^{ t} \equiv 1 (mod \: n)$}, 
	{$a^{ t} \equiv -1 (mod \: n)$}, {$a^{ 2 t} \equiv -1(mod \: n)$},
	{$\dots$}, {$a^{ t 2^{ s-1}} \equiv -1(mod \: n)$}
    \end{enumerate}
  
  \end{definition}

  \begin{definition}    
  
      Составное число {$n \in N$} называется сильно псевдопростым по основанию {$a 
    \in Z_{ n}$}, если число {$a$} является свидетелем простоты числа {$n$}.
    
  \end{definition}

  \begin{statement}   
  
      Пусть {$a$}, {$n \in N$}, {$0 < a < n$}, если число {$a$} не является свидетелем 
    простоты числа {$n$}, то {$n$} - составное.
    
  \end{statement}

\subsection{Тест на свидетельство простоты}

\paragraph{} Пусть даны 2 числа {$a$}, {$n \in N$}, {$n$} - нечетное, {$n - 1 = 2^{ s} t$}, 
{$t$} - нечетное, необходимо проверить, является ли число {$а$} свидетелем простоты числа {$n$} - \cite[Глава 5, страницы 169-170]{mah06}.

  \begin{enumerate}
   \item Если {$(a, n) \ge 1$}, то {$а$} не является свидетелем простоты числа {$n$}, конец алгоритма
   \item Вычисляем {$a^{ t} (mod \: n)$}, если {$a^{ t} \equiv \pm 1(mod \: n)$}, то {$а$}
    - свидетель простоты числа {$n$}, конец алгоритма
   \item Последовательно для {$i=1, \dots, s - 1$} вычисляем {$a^{ t 2^{ i}}(mod \: n)$} и 
    проверяем, если {$a^{ t 2^{ i}} \equiv n - 1 (mod \: n)$}, то {$а$} - 
    свидетель простоты числа {$n$}, иначе {$а$} не является свидетелем простоты числа {$n$}
  \end{enumerate}

  
\subsection{Тест Миллер-Рабина}

\paragraph{}Пусть дано нечетное {$n \in N$}, {$n - 1 = 2^{ s} t$}, {$t$} - нечетное. Необходимо выяснить 
с вероятностью {$1 - 4^{ -k}$}, что {$n$} – составное - \cite[Глава 1.10, страницы 27-29]{ish11},
\cite[Глава 5.1.3, страницы 183-192]{mah06}.
  
  \begin{enumerate}
   \item Пусть {$i = 1$}
   \item Случайным образом выбираем натуральное число {$a$}, {$1 < a < n$}
   \item Если {$a$} не является свидетелем простоты числа {$n$}, то {$n$} - составное, конец алгоритма
   \item Если {$i = k$}, то {$n$} — простое, конец алгоритма, иначе {$i = i + 1$} и переходим к шагу 2
  \end{enumerate}

  \begin{statement}

      Тест Миллера-Рабина определяет, что {$n \in N$} – простое с вероятностью
    {$1 - 4^{ -k}$} менее, чем за {$ 8kN $} арифметических операций, где {$N = \log_{2}{n} + 1 $}
    
  \end{statement}

  \begin{example}    
  
      Пусть {$n = 1729$} – число Кармайкла, разложим {$n - 1 = 2^{ 6} 3^{ 3}$}. 
    Выполним тест Миллера–Рабина для {$a = 2$}:
    
    \begin{enumerate}
      \item {$x_{0} = 2^{ 27} (mod \: 1729) = 625 \ne 1, \ne n - 1$}
      \item {$x_{1} = x_{0}^{2} (mod \: 1729) = 645^{ 2} (mod \: 1729) = 1065$}
      \item {$x_{2} = x_{1}^{2} (mod \: 1729) = 1065^{ 2} (mod \: 1729) = 1$}
    \end{enumerate}
    
    Последующие элементы {${x_{i}}$} для {$i = 3, 4, 5$} равны 1, и последовательность 
  {${x_{1}, x_{2}, \dots, x_{s-1}}$}, 
  не содержит {$n - 1$}. Значит, 2 является свидетелем непростоты {$n$}, и {$n = 1729$} – составное число
  
  \end{example}

\section{Построение больших простых чисел}

\paragraph{} Большие простые числа можно строить сравнительно быстро. При этом можно обеспечить их случайное распределение в 
заданном диапазоне величин. Иначе система шифрования RSA теряла бы всякий практический смысл. Наиболее эффективным средством 
построения простых чисел является \textit{теорема Диемитко}. Рассмотрим ее, ее модификацию, а так же полезное следствие из этой теоремы.

  \begin{lemma}
    Пусть {$n = q^k R + 1 > 1$}, где {$q$} - простое, не являющееся делителем {$R$}. Если существует целое {$a$} такое, что
    {$a^{n-1} \equiv 1 (mod \: n)$}, то найдется простой делитель {$p$} числа {$n$} вида {$p=q^kr+1$} при некотором {$r$}.
    
      \begin{proof}
	Доказательство приведено в \cite[Пункт 12.3, страница 63]{cherem02}
      \end{proof}

  \end{lemma}


  \begin{theorem}[Диемитко]
      Пусть {$n = q R + 1$}, где {$q$} - простое число, {$R$} - четное, {$R < 4(q + 1)$}. Если найдется {$a < n$}:
      
	\begin{enumerate}
	 \item {$a^{n - 1} \equiv 1(mod \: n)$}
	 \item {$a^{\frac{n - 1}{q}} \ncong 1(mod \: n)$}
	\end{enumerate}
	
      то {$n$} – простое число.
      
      \begin{proof}
	Пусть ord $a$ - порядок $a$ по модулю $n$. Условия 1) и 2) означают, что $q$ | ord $a$. В свою очередь ord $a$ делит значение функции
	Эйлера $\varphi(n)$. Таким образом, $q$ | $\varphi(n)$ и $q$ либо совпадает с некоторым простым делителем $p$ числа $n$, либо делит $p - 1$ 
	(если $p^2$ | $n$). Первый случай невозможен, во втором случае $p = qr + 1$ и $n = (qr + 1)(qs + 1)$, где $r$, $s$ — четные, $r \ge 2$.
	Если $n$ - составное, то $s \ge 2$ и, следовательно, $n \ge (2q + 1)^2$. Однако последнее условие нарушается при R < 4(q + 1), и теорема 
	Диемитко доказана. Смотри \cite[Пункт 12.3, страница 63]{cherem02}
      \end{proof}
  \end{theorem} 


  \begin{comment}  
  \begin{theorem}
  
      Пусть \textit{N, S} - нечётные натуральные числа, \textit{N - 1 = S R}, причем для каждого простого делителя \textit{q}  
  числа \textit{S} существует целое число \textit{a} такое, что

    \begin{equation}
      \textit{a\textsuperscript{ N - 1} {$\equiv$} (mod N), (a\textsuperscript{ {$\frac{N - 1}{q}$}} - 1, N) = 1}
    \end{equation}

  Тогда каждый простой делитель \textit{p} числа \textit{N} удовлетворяет сравнению

    \begin{equation}
      \textit{p {$\equiv$} 1(mod 2S)}
    \end{equation}  
  
  \end{theorem}
  
  \begin{cons} 
    Если выполнены условия теоремы (2.1.2) и \textit{R {$\le$} 4S + 2}, то \textit{N} - простое число. Действительно, пусть \textit{N}  
  равняется произведению не менее двух простых чисел. Каждое из них, согласно утверждению теоремы (2.1.1), не меньше, чем \textit{2S + 1}. Но тогда 

    \begin{equation}
      \textit{(2S + 1)\textsuperscript{ 2} {$ \le $} N = S R + 1 {$ \le $} 4S\textsuperscript{ 2} + 2S + 1.}
    \end{equation}

    Противоречие и доказывает следствие.
  \end{cons}
  
  \paragraph{} Полезно показать как, имея большое простое число \textit{S}, можно построить существенно большее простое число \textit{N}. 
  
    \begin{enumerate}
     \item Выберем для этого случайным образом чётное число \textit{R} на промежутке \textit{S {$\le$} R {$\le$} 4S + 2} и положим \textit{N = S R + 1} 
     \item Затем проверим число \textit{N} на отсутствие малых простых делителей, разделив его на малые простые числа
     \item Испытаем \textit{N} некоторое количество раз с помощью алгоритм, проверяющего число на простоту, на пример тест Миллера-Рабина 
     \item Если при этом выяснится, что \textit{N} - составное число, то переходим к шагу 1 
    \end{enumerate}

  Если число \textit{N} выдержало все тесты на простоту, то появляется надежда на то, что \textit{N} - простое число, и следует попытаться 
  доказать простоту с помощью \textit{теоремы Диемитко}. Для этого можно случайным образом выбирать число \textit{a, 1 < a < N},
  и проверять для него выполнимость соотношений

  \begin{equation}
    \textit{a\textsuperscript{ N - 1} {$\equiv$} (mod N), (a\textsuperscript{ R} - 1, N) = 1}.
  \end{equation}
  
  Если при выбранном \textit{a} эти соотношения выполняются, то, согласно следствию из \textit{теоремы Диемитко}, можно 
  утверждать, что число \textit{N} простое. Если же эти условия нарушаются, нужно выбрать другое значение \textit{a} и повторять 
  эти операции до тех пор, пока такое число не будет обнаружено.
  \end{comment}
  
  Можно использовать алгоритм перехода от меньшего простого числа к большему на основе \textit{теоремы Диемитко},
  Итак, если имеем простое число {$q$}, то, перебирая четные числа {$R$}, строим числа {$n = q R + 1$} и испытываем их на 
  простоту согласно теореме Диемитко, пока не получим простое число. По полученному числу можно построить еще одно простое число и так далее,
  пока не будет достигнут требуемый размер числа. 

  
  \subsection{Алгоритм перехода от меньшего простого числа к большему}
    Вход: {$t$} - требуемая размерность простого числа, {$q$} – простое число: |{$q$}|= {$\lceil \frac{t}{2} \rceil$}
    Выход: {$p$} - простое число требуемой размерности
    
      \begin{enumerate}
	\item Вычисляем {$N = \lceil \frac{2^{ t - 1}}{q} \rceil + \lceil \frac{2^{ t - 1} \xi}{q} \rceil$}. 
	Если {$N$} - нечетное, то {$N = N + 1$}, {$\xi$} есть равномерно распределенная на (0,1) случайная величина, получаемая с помощью 
	линейного конгруэнтного генератора. Каждый раз на шаге 1 получают новое значение {$\xi$}.
	\item {$u = 0$}
	\item Вычисляем {$p = (N + u)q + 1$} - кандидат в простые
	\item Если {$p > 2^{ t}$}, возвращаемся на шаг 1
	\item Если {$2^{ p - 1} \equiv 1(mod p)$} и {$2^{ N+u} \ncong 1(mod p)$}, то идем на Выход
	\item Вычисляем {$u = u + 2$}. Возвращаемся на шаг 3
      \end{enumerate}
      
      Проверка на Шаге 4 необходима, чтобы число {$p$} не превышало своей верхней границы, а проверка на Шаге 5 есть проверка условия 
      теоремы Диемитко при {$a=2$}. 
      
      Поскольку на Шаге 5 условие \textit{теоремы Диемитко} проверяется не для всех {$a<p$}, а только для 2, то некоторые простые числа, 
      сгенерированных этим алгоритмом, не опознаются как простые. Но вероятность того, что для простого числа {$N$} наугад выбранное 
      число a будет удовлетворять условиям \textit{теоремы Диемитко}, есть {$1 - \frac{1}{q}$}, а {$q$} – достаточно большое число. Таким образом, проверки
      при {$a=2$} вполне достаточно, чтобы не отсеивать слишком много простых чисел. Выбор {$a=2$} обусловлен тем, что возведение числа 2 
      в степень в двоичном представлении является простой операцией.
      
      \begin{example}
	Вход: {$t = 4$}, {$q = 3 = [11]_{2}$}, \\
	Выход: {$p = 13 = [1011]_{2}$}
	
	  \begin{enumerate}
	   \item {$N = \lceil \frac{8}{3} \rceil + \lceil \frac{8 \times 0.1}{3} \rceil = 4$}, {$4$} - четное число
	   \item {$u = 0$}
	   \item {$p = 4 \times 3 + 1 = 13$}
	   \item {$13 < 2^{ 4} = 16$}
	   \item {$2^{ 12}(mod \: 13) = 1, 2^{ 4}(mod \: 13) = 3$}
	  \end{enumerate}  
	
      \end{example}

  Запишем условие, равносильное условию из теоремы 2.1.1:
  
    \begin{equation}
      \textit{{$ a^{ N - 1} \equiv (mod N), (a^{ R} - 1, N) = 1 $}}.
    \end{equation}
      
  Предположим, что построенное число {$N$} действительно является простым. Зададимся вопросом, сколь долго придётся 
  перебирать числа {$a$}, пока не будет найдено такое, для которого будут выполнены условия (2.1.4). Заметим, что для простого числа {$N$}
  первое условие (2.1.4), согласно малой теореме Ферма, будет выполняться всегда. Те же числа {$a$}, для которых нарушается второе 
  условие (2.1.4), удовлетворяют сравнению

  \begin{equation}
   \textit{{$a^{ R} \equiv 1(mod N)$}}.
  \end{equation}

  Как известно, уравнение {$x^{ R} = 1$} в поле вычетов {$F_{N}$} имеет не более {$R$} решений. 
  Одно из них {$x = 1$}. Поэтому на промежутке {$1 < a < N$} имеется не более {$R - 1$} чисел, для которых не выполняются 
  условия (2.1.4). Это означает, что, выбирая случайным образом числа {$a$} на промежутке {$1 < a < N$}, при простом {$N$}
  можно с вероятностью большей, чем {$1 - O(N^{ -1})$}, найти число \textit{a}, для которого будут выполнены условия 
  теоремы (2.1.1), и тем доказать, что \textit{N} действительно является простым числом.

  \begin{comment}
  Заметим, что построенное таким способом простое число \textit{N} будет удовлетворять неравенству \textit{N > S\textsuperscript{ 2}}, 
  т. е. будет записываться вдвое большим количеством цифр, чем исходное простое число \textit{S}. Заменив теперь число \textit{S} на 
  найденное простое число \textit{N} и повторив с этим новым \textit{S} все указанные выше действия, можно построить еще большее простое 
  число.
  \end{comment}

\begin{comment}
\subsection{Практические рекомендации}

\paragraph{} Поскольку простые числа должны выбираться таким образом, чтобы факторизовать их произведение было вычислительно невозможно, 
рекомендуется брать их очень большими и одинаковой длины.

  Разность чисел \textit{p} и \textit{q} также не должна быть маленькой, поскольку в этом случае \textit{p} эквивалентно \textit{q} и,
следовательно, \textit{p} эквивалентно \textit{{$\sqrt{N}$}}. Таким образом, разложение \textit{N} может быть найдено простым делением 
на все числа порядка \textit{{$\sqrt{N}$}}.

  Числа \textit{p} и \textit{q} должны быть также "устойчивыми" простыми числами. Введем определение “устойчивого числа”:
  
    \begin{definition}   

      Число \textit{p} является устойчивым, если оно удовлетворяет 3 условиям:
	\begin{enumerate}
	 \item Значения \textit{p} и \textit{q} должны различаться по длине всего на несколько разрядов. Например,и \textit{p}, 
и \textit{q} должны попадать в диапазон от \textit{10\textsubscript{ 75}} до \textit{10\textsubscript{ 100}}
	 \item Как \textit{(p - 1)}, так и \textit{(q - 1)} должны содержать в своих разложениях достаточно большой простой множитель.
	 \item \textit{GCD(p - 1, p - 1)} должен быть достаточно малым.
	\end{enumerate}

    \end{definition}

  Эти условия не позволит успешно факторизовать \textit{N} \textit{({$\rho$} - 1)} методом Полларда, который позволяет быстро разложить 
число \textit{N} на множители, если его делитель \textit{p} имеет небольшие (скажем, меньше миллиона) простые делители, позволяет 
избежать \textit{({$\rho$} + 1)} метода Ульямса, позволяющего разложить \textit{N} при условии, что \textit{p + 1} имеет неболшие делители, 
позволит избежать метода безключевого чтения RSA (циклической атаки).

  Кроме того, было показано, что если \textit{e < n} и \textit{d < n\textsuperscript{ {$\frac{1}{4}$}}}, то \textit{d} можно определить достаточно
легко.
  
  Если \textit{p} выбирается случайно и имеет довольно большой размер, то, как правило, \textit{p - 1} и \textit{p + 1} будут иметь 
большие простые делители. Однако выбор устойчивых простых чисел не защищает систему от атаки алгоритмом факторизации на основе 
эллиптических кривых.

  Введем понятие эллиптические кривых.
  
    \begin{definition}
      Эллиптическая кривая над полем \textit{K} - это множество точек проективной плоскости над \textit{K}, удовлетворяющих уравнению
      
	\begin{equation}
	  \textit{y\textsuperscript{ 2} + a\textsubscript{1}xy + a\textsubscript{3}x - x\textsuperscript{ 3} + a\textsubscript{2}x\textsuperscript{ 2} - a\textsubscript{4}x + a\textsubscript{0}}
	\end{equation}
      
      вместе с точкой на бесконечности.    
    \end{definition}
    
  В качестве примера рассмотрим алгоритм факторизации Ленстры целых чисел.
  
  Пусть \textit{N} - составное число, для которого требуется найти наименьший делитель \textit{p}. Рассмотрим множество 
\textit{Z\textsubscript{n} = {0, 1, 2, {$\dots$}, n - 1}} как основное множество для координат точек эллиптической кривой 
\textit{EC(Z\textsubscript{n}) : y\textsuperscript{ 2} = x\textsuperscript{ 3} + ax + b}. В строгом математическом смысле эта кривая 
не будет эллиптической кривой (Ленстра назвал такую кривую псевдокривой), так как \textit{F} не является полем, и, значит, в нем не 
всегда выполнимы операции нахождения обратного элемента, необходимые для нахождения суммы точек кривой. Однако Ленстра заметил, 
что невозможность вычисления суммы двух точек \textit{P (x\textsubscript{1}, y\textsubscript{1})} и \textit{Q(x\textsubscript{2}, y\textsubscript{2})} означает,
что разность первых координат \textit{x\textsubscript{2} - x\textsubscript{1}} должны равняться 0 по модулю одного из делителей \textit{N}, 
тогда, вычисляя наибольший общий делитель \textit{GCD(n, \textsubscript{2} - x\textsubscript{1})}, мы легко найдем искомый делитель. 
Суть алгоритма Ленстры заключается в выборе на псевдокривой EC(Z\textsubscript{n}) произвольной базовой точки \textit{P\textsubscript{0}} 
и домножении ее на всевозможные простые числа и их степени пока не получим \textit{kP\textsubscript{0} {$\equiv$} {$\infty$}(mod p)}, 
где \textit{p} - один из делителей \textit{N}.
 
  Получить устойчивые простые числа можно следующим способом: генерируем большие простые числа \textit{s} и \textit{t}. Затем 
получаем такое число \textit{r}, что \textit{r - 1} делится на \textit{t} (для этого рассматриваем нечетные числа вида
\textit{kt + 1}, где \textit{k} - последовательные натуральные числа, и проверяем их на простоту, пока не найдем простое). 
Затем вычисляя 

  \begin{equation}
   \textit{p {$\equiv$} (sr - 1 - rs - 1)(mod rs) + xrs,}
  \end{equation}

где \textit{x} - некоторое целое число и проверяя \textit{p} на простоту, находим устойчивое простое число \textit{p}.
\end{comment}  
