% !TEX root = ../DiplomProject.tex

\paragraph{} Существует довольно эффективный способ убедиться, что заданное число является составным, не разлагая это число на множители. 
Согласно малой теореме Ферма, если число \textit{n} простое, то для любого целого \textit{a}, не делящегося на \textit{n}, выполняется сравнение
\begin{equation} \label{eq:prime-big-an1}
 a^{ n-1} \equiv 1 (mod \: n).
\end{equation}
Если же при каком-то {$a$} это сравнение нарушается, можно утверждать, что {$n$} - составное. Вопрос только в том, как найти для составного {$n$}
целое число {$a$}, не удовлетворяющее (\ref{eq:prime-big-an1}). Можно, например, пытаться найти необходимое число {$a$}, испытывая все целые числа подряд, 
начиная с {$2$}. Или попробовать выбирать эти числа случайным образом на отрезке {$1 < a < n$}.

  К сожалению, такой подход не всегда даёт то, что хотелось бы. Имеются составные числа {$n$}, обладающие свойством (\ref{eq:prime-big-an1}) для любого целого
{$a$} с условием {$(a, n) = 1$}. Такие числа называются числами Кармайкла. Рассмотрим, например, число {$561 = 3 \cdot 11 \cdot 17$}. 
Так как 560 делится на каждое из чисел 2, 10, 16, то с помощью малой теоремы Ферма легко проверить, что 561 есть число Кармайкла. 
Можно доказать, что любое из чисел Кармайкла имеет вид {$n = p_{1} \dots p_{r}, r \geq 3$}, 
где все простые {$p_{i}$} различны, причем {$n - 1$} делится на каждую разность {$p_{i} - 1$}. 
Лишь недавно, была решена проблема о бесконечности множества таких чисел.

  В 1976 г. Миллер предложил заменить проверку (\ref{eq:prime-big-an1}) проверкой несколько иного условия. Если {$n$} - простое число, 
{$n - 1 = 2^{ s} t$}, где {$t$} нечётно, то согласно малой теореме Ферма для каждого {$a$} с 
условием {$(a, n) = 1$} хотя бы одна из скобок в произведении
\begin{equation} \label{eq:prime-big-at1}
 (a^{ t} - 1)(a^{ t} + 1)(a^{ 2 t} + 1) \dots (a^{ 2^{ s - 1}t} + 1) = a^{ n - 1} - 1
\end{equation}
делится на \textit{n}. Обращение этого свойства можно использовать, чтобы отличать составные числа от простых`.

Пусть {$n$} - нечётное составное число, {$n - 1 = 2^{s} t$}, где {$t$} нечётно. Назовем целое число {$a$},
{$1 < a < n$}, «хорошим» для {$n$}, если нарушается одно из двух условий: 
\begin{enumerate}
 \item {$n$} не делится на {$a$};
 \item {$a^{ t} \equiv 1 (mod \: n)$} или существует целое \textit{k}, {$0 \leq k \leq s$}, такое, что
  \begin{equation}
      \textit{{$a^{ 2^{ k} t} \equiv -1 (mod \: n)$}}
  \end{equation}

\end{enumerate}
Из сказанного ранее следует, что для простого числа {$n$} не существует хороших чисел {$a$}. Если же {$n$} составное число, 
то, как доказал Рабин, их существует не менее {$\dfrac{3}{4}(n - 1)$}.


\section{Проверка большого числа на простоту}

\paragraph{} Перед описанием некоторых алгоритмов и тестов на простоту чисел введем определения и утверждения

  \begin{definition}    
  
      Пусть {$n \in N$} нечетное число и {$n - 1 = 2^{ s} t$}, {$t$} – нечетное,
    число {$a \in N$}, такое, что {$0 < a < n$}, называется свидетелем 
    простоты числа {$n$}, если выполнены 2 условия:

    \begin{enumerate}
      \item {$(a, n) = 1$}
      \item Справедливо хотя бы одно из сравнений {$a^{ t} \equiv 1 (mod \: n)$}, 
	{$a^{ t} \equiv -1 (mod \: n)$}, {$a^{ 2 t} \equiv -1(mod \: n)$},
	{$\dots$}, {$a^{ t 2^{ s-1}} \equiv -1(mod \: n)$}
    \end{enumerate}
  
  \end{definition}

  \begin{definition}    
  
      Составное число {$n \in N$} называется сильно псевдопростым по основанию {$a 
    \in Z_{ n}$}, если число {$a$} является свидетелем простоты числа {$n$}.
    
  \end{definition}

  \begin{statement}   
  
      Пусть {$a$}, {$n \in N$}, {$0 < a < n$}, если число {$a$} не является свидетелем 
    простоты числа {$n$}, то {$n$} - составное.
    
  \end{statement}

\subsection{Тест на свидетельство простоты}

\paragraph{} Пусть даны 2 числа {$a$}, {$n \in N$}, {$n$} - нечетное, {$n - 1 = 2^{s} t$}, 
{$t$} - нечетное, необходимо проверить, является ли число {$a$} свидетелем простоты числа {$n$} - \cite[Глава 5, страницы 169-170]{mah06}.

  \begin{enumerate}
   \item Если {$(a, n) \ge 1$}, то {$a$} не является свидетелем простоты числа {$n$}, конец алгоритма
   \item Вычисляем {$a^{ t} (mod \: n)$}, если {$a^{ t} \equiv \pm 1(mod \: n)$}, то {$a$}
    - свидетель простоты числа {$n$}, конец алгоритма
   \item Последовательно для {$i=1, \dots, s - 1$} вычисляем {$a^{ t 2^{ i}}(mod \: n)$} и 
    проверяем, если {$a^{ t 2^{ i}} \equiv n - 1 (mod \: n)$}, то {$a$} - 
    свидетель простоты числа {$n$}, иначе {$a$} не является свидетелем простоты числа {$n$}
  \end{enumerate}

  
\subsection{Тест Миллер-Рабина}

\paragraph{} Рабин доказал теорему о том, что если нечетное число $n > 2$ - составное, то множество свидетелей его простоты имеет мощность не более
$\frac{\varphi(n)}{4} < \frac{n}{4}$. Отсюда следует, что если при проверке $k$ произвольно выбранных чисел $a < n$ все они окажутся свидетелями простоты $n$, то $n$ -
простое с вероятностью ошибки, не превышающей $4^{ -k}$. На этом наблюдении строится следующий тест Миллера–Рабина.

Пусть дано нечетное {$n \in N$}, {$n - 1 = 2^{ s} t$}, {$t$} - нечетное. Необходимо выяснить 
с вероятностью {$1 - 4^{ -k}$}, что {$n$} – составное - \cite[Глава 1.10, страницы 27-29]{ish11},
\cite[Глава 5.1.3, страницы 183-192]{mah06}.
  
  \begin{enumerate}
   \item Пусть {$i = 1$}
   \item Случайным образом выбираем натуральное число {$a$}, {$1 < a < n$}
   \item Если {$a$} не является свидетелем простоты числа {$n$}, то {$n$} - составное, конец алгоритма
   \item Если {$i = k$}, то {$n$} — простое, конец алгоритма, иначе {$i = i + 1$} и переходим к шагу 2
  \end{enumerate}

  \begin{statement}
      Тест Миллера-Рабина определяет, что {$n \in N$} – простое с вероятностью
    {$1 - 4^{ -k}$} менее, чем за {$ 8kN $} арифметических операций, где {$N = \log_{2}{n} + 1 $}
    
  \end{statement}

  \begin{example}    
  
      Пусть {$n = 1729$} – число Кармайкла, разложим {$n - 1 = 2^{ 6} 3^{ 3}$}. 
    Выполним тест Миллера–Рабина для {$a = 2$}:
    
    \begin{enumerate}
      \item {$x_{0} = 2^{ 27} (mod \: 1729) = 625 \ne 1, \ne n - 1$}
      \item {$x_{1} = x_{0}^{2} (mod \: 1729) = 645^{ 2} (mod \: 1729) = 1065$}
      \item {$x_{2} = x_{1}^{2} (mod \: 1729) = 1065^{ 2} (mod \: 1729) = 1$}
    \end{enumerate}
    
    Последующие элементы {${x_{i}}$} для {$i = 3, 4, 5$} равны 1, и последовательность 
  {${x_{1}, x_{2}, \dots, x_{s-1}}$}, 
  не содержит {$n - 1$}. Значит, 2 является свидетелем непростоты {$n$}, и {$n = 1729$} – составное число. Сложность алгоритма равна $O((\log{n})^3)$ - \cite[Глава 5.1.3, страница 184]{mah06}
  
  \end{example}

  \begin{lemma} \label{eq:prime-big-rabin-theorem}
    Пусть число $n$ - нечетное число, и $n-1 = 2^{s} d$, где $d$ - нечетно. Если для всех $x$, $0 < x < 2(log_{2}{n})^2$
    выполняется $x^d \equiv 1 (mod \: n)$, или $ x^{2^{ k} d} \equiv -1 (mod \: n)$ для некоторого $0 \le k < s$. Тогда число $n$ является простым.
  \end{lemma}

    Описанная выше теорема была доказана Рабином при условии справедливости обобщенной гипотезы Римана о распределении простых чисел, соответственно, не смотря на то, что
  оценка, приведенная в лемме, является полиномиальной, она не может быть использована, поскольку гипотеза Римана не доказана. - \cite[Глава 1.10, страница 29]{ish11}

\section{Построение больших простых чисел}

\paragraph{} Большие простые числа можно строить сравнительно быстро. При этом можно обеспечить их случайное распределение в 
заданном диапазоне величин. Иначе система шифрования RSA теряла бы всякий практический смысл. Наиболее эффективным средством 
построения простых чисел является \textit{теорема Диемитко}. Рассмотрим ее, ее модификацию, а так же полезное следствие из этой теоремы.

  \begin{lemma}
    Пусть {$n = q^k R + 1 > 1$}, где {$q$} - простое, не являющееся делителем {$R$}. Если существует целое {$a$} такое, что
    {$a^{n-1} \equiv 1 (mod \: n)$}, то найдется простой делитель {$p$} числа {$n$} вида {$p=q^kr+1$} при некотором {$r$}.
    
      \begin{proof}
	Доказательство приведено в \cite[Пункт 12.3, страница 63]{cherem02}
      \end{proof}

  \end{lemma}


  \begin{theorem}[Диемитко] \label{eq:prime-theorem-diemitko}
      Пусть {$n = q R + 1$}, где {$q$} - простое число, {$R$} - четное, {$R < 4(q + 1)$}. Если найдется {$a < n$}:
      
	\begin{enumerate}
	 \item {$a^{n - 1} \equiv 1(mod \: n)$}
	 \item {$a^{\frac{n - 1}{q}} \not\equiv 1(mod \: n)$}
	\end{enumerate}
	
      то {$n$} – простое число.
      
      \begin{proof}
	Пусть ord $a$ - порядок $a$ по модулю $n$. Условия 1) и 2) означают, что $q$ | ord $a$. В свою очередь ord $a$ делит значение функции
	Эйлера $\varphi(n)$. Таким образом, $q$ | $\varphi(n)$ и $q$ либо совпадает с некоторым простым делителем $p$ числа $n$, либо делит $p - 1$ 
	(если $p^2$ | $n$). Первый случай невозможен, во втором случае $p = qr + 1$ и $n = (qr + 1)(qs + 1)$, где $r$, $s$ — четные, $r \ge 2$.
	Если $n$ - составное, то $s \ge 2$ и, следовательно, $n \ge (2q + 1)^2$. Однако последнее условие нарушается при R < 4(q + 1), и теорема 
	Диемитко доказана. Смотри \cite[Пункт 12.3, страница 63]{cherem02}
      \end{proof}
  \end{theorem} 
 
  Можно использовать алгоритм перехода от меньшего простого числа к большему на основе \textit{теоремы Диемитко},
  Итак, если имеем простое число {$q$}, то, перебирая четные числа {$R$}, строим числа {$n = q R + 1$} и испытываем их на 
  простоту согласно теореме Диемитко, пока не получим простое число. По полученному числу можно построить еще одно простое число и так далее,
  пока не будет достигнут требуемый размер числа. 

  
  \subsection{Алгоритм перехода от меньшего простого числа к большему}
    Вход: {$t$} - требуемая размерность простого числа, {$q$} – простое число: |{$q$}|= {$\lceil \frac{t}{2} \rceil$}
    Выход: {$p$} - простое число требуемой размерности
    
      \begin{enumerate}
	\item Вычисляем {$N = \lceil \frac{2^{ t - 1}}{q} \rceil + \lceil \frac{2^{ t - 1} \xi}{q} \rceil$}. 
	Если {$N$} - нечетное, то {$N = N + 1$}, {$\xi$} есть равномерно распределенная на (0,1) случайная величина, получаемая с помощью 
	линейного конгруэнтного генератора. Каждый раз на шаге 1 получают новое значение {$\xi$}.
	\item {$u = 0$}
	\item Вычисляем {$p = (N + u)q + 1$} - кандидат в простые
	\item Если {$p > 2^{ t}$}, возвращаемся на шаг 1
	\item Если {$2^{ p - 1} \equiv 1(mod \: p)$} и {$2^{ N+u} \not\equiv 1(mod \: p)$}, то идем на Выход
	\item Вычисляем {$u = u + 2$}. Возвращаемся на шаг 3
      \end{enumerate}
      
      Проверка на Шаге 4 необходима, чтобы число {$p$} не превышало своей верхней границы, а проверка на Шаге 5 есть проверка условия 
      теоремы Диемитко при {$a=2$}. 
      
      Поскольку на Шаге 5 условие \textit{теоремы Диемитко} проверяется не для всех {$a<p$}, а только для 2, то некоторые простые числа, 
      сгенерированных этим алгоритмом, не опознаются как простые. Но вероятность того, что для простого числа {$N$} наугад выбранное 
      число a будет удовлетворять условиям \textit{теоремы Диемитко}, есть {$1 - \frac{1}{q}$}, а {$q$} – достаточно большое число. Таким образом, проверки
      при {$a=2$} вполне достаточно, чтобы не отсеивать слишком много простых чисел. Выбор {$a=2$} обусловлен тем, что возведение числа 2 
      в степень в двоичном представлении является простой операцией.
      
      \begin{example}
	Вход: {$t = 4$}, {$q = 3 = [11]_{2}$}, \\
	Выход: {$p = 13 = [1011]_{2}$}
	
	  \begin{enumerate}
	   \item {$N = \lceil \frac{8}{3} \rceil + \lceil \frac{8 \times 0.1}{3} \rceil = 4$}, {$4$} - четное число
	   \item {$u = 0$}
	   \item {$p = 4 \times 3 + 1 = 13$}
	   \item {$13 < 2^{ 4} = 16$}
	   \item {$2^{ 12}(mod \: 13) = 1, 2^{ 4}(mod \: 13) = 3$}
	  \end{enumerate}  
	
      \end{example}

  Запишем условие, равносильное условию из теоремы (\ref{eq:prime-theorem-diemitko}):
  
    \begin{equation} \label{eq:prime-big-aN1}
       a^{ N - 1} \equiv (mod N), (a^{ R} - 1, N) = 1.
    \end{equation}
      
  Предположим, что построенное число {$N$} действительно является простым. Зададимся вопросом, сколь долго придётся 
  перебирать числа {$a$}, пока не будет найдено такое, для которого будут выполнены условия (\ref{eq:prime-big-aN1}). Заметим, что для простого числа {$N$}
  первое условие (\ref{eq:prime-big-aN1}), согласно малой теореме Ферма, будет выполняться всегда. Те же числа {$a$}, для которых нарушается второе 
  условие (\ref{eq:prime-big-aN1}), удовлетворяют сравнению

  \begin{equation} \label{eq:prime-big-ar1}
   a^{ R} \equiv 1(mod N).
  \end{equation}

  Как известно, уравнение {$x^{ R} = 1$} в поле вычетов {$F_{N}$} имеет не более {$R$} решений. 
  Одно из них {$x = 1$}. Поэтому на промежутке {$1 < a < N$} имеется не более {$R - 1$} чисел, для которых не выполняются 
  условия (\ref{eq:prime-big-aN1}). Это означает, что, выбирая случайным образом числа {$a$} на промежутке {$1 < a < N$}, при простом {$N$}
  
  можно с вероятностью большей, чем {$1 - O(N^{ -1})$}, найти число \textit{a}, для которого будут выполнены условия 
  теоремы (\ref{eq:prime-theorem-diemitko}), и тем доказать, что \textit{N} действительно является простым числом.

\section{Заключение}

\paragraph{} Оценка, приведенная в лемме (\ref{eq:prime-big-rabin-theorem}), является полиномиальной, однако, с теоретической точки зрения она не может быть использована, пока не доказана обобщенная гипотеза Римана, которая на сегодняшний день является самой известной из нерешенных «проблем тысячелетия». Кроме того, для практических расчетов эта оценка является сильно завышенной. Вместо нее обычно используется граница порядка $O(\log_{2}{n})$. Изначальный алгоритм, предложенный Миллером, был детерминированным и состоял в проверке всех a от $2$ до $70 \ln^{2}n$. Алгоритм Миллера гарантированно распознает простые и составные числа при условии выполнения обобщённой гипотезы Римана. 

  В случае, когда верхняя граница перебора задаётся функцией $f(n)=2 \cdot log^{2}(n)$, то алгоритм детерминировано проверяет простоту числа $n$ за
$O(\log^{4}(n))$, но при этом алгоритм опирается на расширенную гипотезу Римана. В случае, когда $f(n)=n^{0.133}$, время работы в худшем случае оценивается как $O(n^{1/7})$.

  Алгоритм Миллера-Рабина не зависит от справедливости обобщённой гипотезы Римана, но является вероятностным.

  Поскольку в главе рассматривалось 2 алгоритма получения больших простых чисел то важно провести сравнение алгоритма Миллер-Рабина и алгоритма, основанного на теореме Диемитко (\ref{eq:prime-theorem-diemitko}), и выбрать наиболее подходящий для криптосистемы RSA. Краткое сравнение приведено в таблице \ref{prime-compare-label}

  \begin{table}[h]
    \centering
    \begin{tabular}{|l|l|l|l|}   
        \hline 
        \textbf{Метод} & \textbf{Вероятностный} & \textbf{Точный} & \textbf{Полиномиальный} \\ \hline        
        Миллер-Рабин        & \textbf{+}           & -                & \textbf{+}              \\ \hline
        Диемитко            & -           & \textbf{+}                 & \textbf{+}              \\ \hline        
    \end{tabular} 
    \caption{Сравнение методов Миллера-Рабина и Диемитко}
    \label{prime-compare-label}
  \end{table}

  Как видно из таблицы, у каждого из алгоритмов есть свои плюсы и минусы, помимо этого алгоритмы выполняют разные задачи. Алгоритм Миллер-Рабина принимает нечетное число 
и проверяет его на простоту, в то время как алгоритм Диемитко (\ref{eq:prime-theorem-diemitko}) принимает простое число и возвращает большее простое число. Алгоритмы Миллера-
Рабина и Диемитко (\ref{eq:prime-theorem-diemitko}) оба используют вероятностную составляющую (в алгоритме Диемитко используется равномерно распределенная на 
$(0,1)$ случайная величина), однако, если алгоритм Миллер-Рабина выдает правильный результат с вероятностью, то алгоритм Диемтико (\ref{eq:prime-theorem-diemitko}) всегда дает точный и корректный результат. Оба алгоритма работаю за полиномиальное время, а значит работают достаточно быстро для того, чтобы подходить шифра RSA, однако алгоритм, основанный на теореме Диемитко (\ref{eq:prime-theorem-diemitko}) больше подходит для задач шифра RSA, поскольку он всегда дает точный результат и его задачей является построение простых чисел, а не тестирование, соответственно мы сможет быстро получить заведомо простое число и не придется опираться на вероятность, подавая алгоритму Миллер-Рабина нечетные числа.



%   В противовес алгоритму Миллер-Рабина можно рассмотреть веротятностный \textit{алгоритм Соловея-Штрассена} - 
% \cite[Глава 11.5, страница 47]{cherem02}. В каждом раунде алгоритма вероятность отсеять составное число больше $1/2$, поэтому через $k$ раундов 
% \textit{тест Соловея–Штрассена} определяет простое число с вероятностью ошибки, меньшей $2^{-k}$. Поэтому этот тест сравним по эффективности с 
% тестом Ферма, но имеет преимущество перед тестом Ферма в том, что он отсеивает все числа Кармайкла. С другой стороны, он проигрывает тесту 
% Миллера–Рабина,который за $k$ раундов имеет ошибку, меньшую $4^{-k}$. Общая вычислительная сложность алгоритма оценивается как $O(k \log_{2} n)$.

%   В начале 80-х годов Адлеман, Померанс и Румели предложили детерминированный алгоритм проверки простоты чисел. Для заданного
% натурального числа $n$ алгоритм делает $O((\log n)^{c \log \log \log n})$ арифметических операций ($c$ — некоторая абсолютная постоянная) и выдает верный
% ответ, составное $n$ или простое. Этот алгоритм оказался непрактичным и довольно сложным для реализации на компьютере.

%   Существенные теоретические упрощения алгоритма Адлемана-Померанса-Румели были получены Х. Ленстрой. Он предложил
% детерминированный алгоритм, также делающий $O((\log n)^{c \log \log \log n})$ арифметических операций. Реализация этого алгоритма позволила
% проверять на простоту числа $n$ порядка $10^{100}$ за несколько минут. 

%   Оценка сложности в алгоритмах Адлемана-Померанса-Румели и Ленстры является неулучшаемой, тоесть для простого
% числа $n$ алгоритм выполнит не менее $c_{1} (\log n)^{c_2 \log \log \log n}$ операций для некоторых положительных постоянных $c_1$ и $c_2$.