\section{Применение RSA}

\paragraph{} Крайне не рекомендуется использовать \textit{RSA} в его наиболее простой форме, существуют требования, выдвигаемые к асимметричным криптосистемам.

\subsection{Пример 1}

\paragraph{} Современная асимметричная криптосистема может считаться стойкой, если злоумышленник, имея два открытых текста \textit{M\textsubscript{1}} и \textit{M\textsubscript{2}}, а также один шифротекст \textit{C\textsubscript{b}} не может с вероятностью большей, чем 0.5 определить какому из двух открытых текстов соответствует шифротекст \textit{C\textsubscript{b}}.

Проверим, удовлетворяет ли \textit{RSA} данному требованию. Пусть злоумышленник прослушивает переписку \textit{А} и \textit{B}. Злоумышленник видит, что \textit{B} в открытом виде задал \textit{A} вопрос. \textit{A} односложно отвечает \textit{B} на этот вопрос. \textit{A} шифрует свой ответ открытым ключом \textit{B} и отправляет шифротекст. Далее злоумышленник перехватывает шифротекст и подозревает, что в нем зашифровано либо Да, либо Нет. Всё, что ему теперь нужно сделать для того чтобы узнать ответ \textit{A} это зашифровать открытым ключом \textit{B} слово Да и если полученный криптотекст совпадет с перехваченным, то это означает, что \textit{A} ответила Да, в противном же случает злоумышленник поймет, что ответом было Нет.

Как видно из примера, \textit{RSA} не столь надежна как это принято считать. Чтобы избежать подобных ситуаций, достаточно чтобы алгоритм добавлял к тексту некоторую случайную информацию, которую бы невозможно было предугадать. 

\subsection{Пример 2}

\paragraph{} Рассмотрим следующий пример: пусть злоумышленник имеет доступ к расшифровывающему «черному ящику». Таким образом любой криптотекст по просьбе злоумышленника может быть расшифрован. Далее злоумышленник создает два открытых текста \textit{M\textsubscript{1}} и \textit{M\textsubscript{2}}. Один из этих текстов шифруется и полученный в результате криптотекст \textit{C\textsubscript{b}} возвращается злоумышленнику. Задача злоумышленника угадать с вероятностью большей чем 0.5 какому из сообщений \textit{M\textsubscript{1}} и \textit{M\textsubscript{2}} соответсвует криптотекст \textit{C\textsubscript{b}}. При этом он может попросить расшифровать любое сообщение, кроме \textit{C\textsubscript{b}}. Говорят что криптосистема стойкая, если злоумышленник, даже в таких прекрасных для себя условиях, не сможет указать какому исходному тексту соответствует \textit{C\textsubscript{b}}  с вероятностью большей 0.5.

Рассмотрим насколько криптостойкой окажется \textit{RSA} в данном случае. Итак, злоумышленник имеет два сообщения \textit{M\textsubscript{1}} и \textit{M\textsubscript{2}}. А также криптотекст \textit{C\textsubscript{b}=M\textsubscript{1}\textsuperscript{e}(mod n)}. Ему необходимо указать какому конкретно из двух текстов соответствует \textit{C\textsubscript{b}}. Для этого он может предпринять следующее. Зная открытый ключ \textit{e}, он может создать сообщение \textit{C'=2\textsuperscript{e} C\textsubscript{b}(mod n)}. Далее он просит расшифровывающий «черный ящик» расшифровать сообщение \textit{C'}. А затем несложная арифметика ему в помощь. Имеем:

\begin{center}
	\textit{M'=C'\textsuperscript{d}(mod n)=2\textsuperscript{e d}M\textsubscript{1}\textsuperscript{e d}(mod n)=2M\textsubscript{1}(mod n).} 
\end{center}

Таким образом вычислив \textit{M'/2} злоумышленник увидит \textit{M\textsubscript{1}}. А это означает, что он поймет что в нашем примере было зашифровано сообщение \textit{M\textsubscript{1}}, а следовательно мы еще раз убедились в неприемлемости использования \textit{RSA} в его изначальном виде на практике.

\subsection{RSA-OAEP}

\paragraph{} Таким образом, уже сейчас можно сказать, что \textit{RSA} во всех своих проявлениях будь то \textit{PGP} или \textit{SSL} не шифрует только отправленные на вход шифрующей функции данные. Алгоритм сперва добавляет к этим данным блоки содержащие случайный набор бит. И только после этого полученный результат шифруется. Это значит, что вместо привычной всем \textit{c=m\textsuperscript{e}(mod n)} получаем более близкую к действительности \textit{c=(m||r)\textsuperscript{e}(mod n)}, где \textit{r} - случайное число. Такую методику называют схемами дополнения. В настоящее время использование \textit{RSA} без схем дополнения является не столько плохим тоном, сколько непосредственно нарушением стандартов.

Устранить и эту неприятность помогают схемы дополнения. Только теперь к ним выдвигается требование не только о том, чтобы дополнительная информация была абсолютно случайной и непрогнозируемой. Но так же и том, чтобы дополнительные блоки помогали определить был ли шифротекст получен в результате работы шифрующей функции или он смоделирован злоумышленником. Причем в случае, если будет обнаружено, что шифротекст смоделирован вместо расшифрованных данных атакующему будет выдано сообщение о несоответствие данных реальному криптотексту.

В \textit{RSA} при подписи и при шифровании данных используют две различные схемы дополнений. Схема, реализуемая для подписания документов, называется \textit{RSA-PSS(probabilistic signature scheme)} или вероятностная схема подписи. Схема, используемая при шифровании – \textit{RSA-OAEP(Optimal asymmetric encryption padding)} или оптимизированное асимметричное дополнение шифрования, на примере \textit{OAEP} и рассмотрим как на самом деле происходит шифрование сообщений в \textit{RSA}.

Итак чтобы зашифровать абсолютно любое сообщение в \textit{RSA-OAEP} делается следующее: \\*
Выбираются две хеш-функции \textit{G(x)} и \textit{H(x)} таким образом, чтобы суммарная длина результатов хеш-функций не превышала длины ключа \textit{RSA}. Генерируется случайная строка битов \textit{l}. Длина строки должна быть равна длине результата хеш-функции \textit{H(x)}.

Итак чтобы зашифровать абсолютно любое сообщение в \textit{RSA-OAEP} делается следующее:
\begin{enumerate}
	\item Выбираются две хеш-функции \textit{G(x)} и \textit{H(x)} таким образом, чтобы суммарная длина результатов хеш-функций не превышала длины ключа \textit{RSA}.
	\item Генерируется случайная строка битов \textit{l}. Длина строки должна быть равна длине результата хеш-функции \textit{H(x)}.
	\item Сообщение \textit{M} разбивают на блоки по \textit{k-бит}. Затем к каждому полученному блоку \textit{m} дописывают \textit{(n-k)} нулей. Где \textit{n-длина} хеш-функции \textit{G(x)}.
	\item Определяют следующий набор бит: \{m||0\textsuperscript{(n-k)}{$\oplus$}G(l)\}||\{l{$\oplus$}H(m||0\textsuperscript{(n-k)}{$\oplus$}G(l))\}
	\item Полученные биты представляют в виде целого числа \textit{M\textsubscript{1}}
	\item Криптотекст получают по формуле: \textit{C=M\textsubscript{1}\textsuperscript{e}(mod n)}
\end{enumerate}

Процесс дешифрования выглядит следующим образом:
\begin{enumerate}
	\item Находят \textit{M\textsubscript{1}} по формуле \textit{M\textsubscript{1}=C\textsuperscript{d}(mod n)}
	\item В полученном наборе бит отсекают левую часть. В смысле: левой частью служат \textit{n} левых бит числа \textit{M\textsubscript{1}} где \textit{n}-длина хеш-функции \textit{G(x)}. Обозначим эти биты условно \textit{T}. И заметим, что \textit{T=\{m||0\textsuperscript{(n-k)} {$\oplus$} G(l)\}}. Все остальные биты являются правой частью.
	\item Находим \textit{H(T)=H(m||0\textsuperscript{(n-k)} G(l))}
	\item Зная H(T) получаем l, поскольку знаем l {$\oplus$} H(T)-это правая часть блока
	\item Вычислив l, находим m из T{$\oplus$}G(l), поскольку T=\{m||0\textsuperscript{(n-k)}{$\oplus$}G(l)\}
	\item Если \textit{m} заканчивается \textit{(n-k)}-нулями значит сообщение зашифровано правильно. Если нет то это значит, что шифротекст некорректен, а следовательно он скорее всего подделан злоумышленником.
\end{enumerate}

Таким образом \textit{RSA} это не только возведение в степень по модулю большого числа. Это еще и добавление избыточных данных позволяющих реализовать дополнительную защиту вашей информации. Вы, возможно, спросите: а зачем это все нужно? Неужели в действительности может произойти такая ситуация, когда атакующий получит доступ к расшифровывающему алгоритму? Совсем по другому поводу как-то было сказано: если какая-либо неприятность может произойти, она обязательно произойдет.