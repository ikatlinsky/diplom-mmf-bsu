% !TEX root = ../DiplomProject.tex

\section{Применение RSA}

\paragraph{} Крайне не рекомендуется использовать \textit{RSA} в его наиболее простой форме, существуют требования, выдвигаемые к асимметричным криптосистемам
- \cite[страницы 329-331]{may10}.

\subsection{Пример 1}

\paragraph{} Современная асимметричная криптосистема может считаться стойкой, если злоумышленник, имея два открытых текста {$M_1$} и 
  {$M_2$}, а также один шифротекст {$C_b$} не может с вероятностью большей, чем 0.5 определить какому из двух 
  открытых текстов соответствует шифротекст {$C_b$}.

  Проверим, удовлетворяет ли \textit{RSA} данному требованию. Пусть злоумышленник прослушивает переписку \textit{А} и \textit{B}. Злоумышленник видит, что 
  \textit{B} в открытом виде задал \textit{A} вопрос. \textit{A} односложно отвечает \textit{B} на этот вопрос. \textit{A} шифрует свой ответ открытым ключом
  \textit{B} и отправляет шифротекст. Далее злоумышленник перехватывает шифротекст и подозревает, что в нем зашифровано либо Да, либо Нет. Всё, что ему 
  теперь нужно сделать для того чтобы узнать ответ \textit{A} это зашифровать открытым ключом \textit{B} слово Да и если полученный криптотекст совпадет 
  с перехваченным, то это означает, что \textit{A} ответила Да, в противном же случае злоумышленник поймет, что ответом было Нет.

  Как видно из примера, \textit{RSA} не столь надежна как это принято считать. Чтобы избежать подобных ситуаций, достаточно чтобы алгоритм добавлял к 
  тексту некоторую случайную информацию, которую бы невозможно было предугадать. 

\subsection{Пример 2}

\paragraph{} Рассмотрим следующий пример: пусть злоумышленник имеет доступ к расшифровывающему «черному ящику». Таким образом любой криптотекст по просьбе 
  злоумышленника может быть расшифрован. Далее злоумышленник создает два открытых текста {$M_1$} и {$M_2$}. 
  Один из этих текстов шифруется и полученный в результате криптотекст {$C_b$} возвращается злоумышленнику. Задача злоумышленника 
  угадать с вероятностью большей чем 0.5 какому из сообщений {$M_1$} и {$M_2$} соответсвует криптотекст 
  {$C_b$}. При этом он может попросить расшифровать любое сообщение, кроме {$C_b$}. Говорят что криптосистема 
  стойкая, если злоумышленник, даже в таких прекрасных для себя условиях, не сможет указать какому исходному тексту соответствует {$C_b$}
  с вероятностью большей 0.5.

  Рассмотрим насколько криптостойкой окажется \textit{RSA} в данном случае. И так, злоумышленник имеет два сообщения {$M_1$} и 
  {$M_2$}. А также криптотекст {$C_{b}=M^{e}_{1}(mod n)$}. Ему необходимо указать какому 
  конкретно из двух текстов соответствует {$C_b$}. Для этого он может предпринять следующее. Зная открытый ключ \textit{e}, он может 
  создать сообщение {$C'=2^{e} C_{b}(mod n)$}. Далее он просит расшифровывающий «черный ящик» расшифровать сообщение 
  \textit{C'}. А затем несложная арифметика ему в помощь. Имеем:

    \begin{equation}
      \textit{{$M'=C'^d(mod n)=2^{e d}M_{1}^{e d}(mod n)=2M_{1}(mod n).$}} 
    \end{equation}

  Таким образом вычислив {$\rfrac{M'}{2}$} злоумышленник увидит {$M_1$}. А это означает, что он поймет что в нашем примере было зашифровано 
  сообщение {$M_1$}, а следовательно мы еще раз убедились в неприемлемости использования \textit{RSA} в его изначальном виде на практике.

\subsection{RSA-OAEP}

\paragraph{} Таким образом, уже сейчас можно сказать, что \textit{RSA} во всех своих проявлениях будь то \textit{PGP} или \textit{SSL} не шифрует только 
  отправленные на вход шифрующей функции данные. Алгоритм сперва добавляет к этим данным блоки содержащие случайный набор бит. И только после этого полученный
  результат шифруется. Это значит, что вместо привычной всем {$c=m^{e}(mod n)$} получаем более близкую к действительности 
  {$c=(m||r)^{e}(mod n)$}, где \textit{r} - случайное число. Такую методику называют схемами дополнения. В настоящее время использование
  \textit{RSA} без схем дополнения является не столько плохим тоном, сколько непосредственно нарушением стандартов.

  Устранить и эту неприятность помогают схемы дополнения. Только теперь к ним выдвигается требование не только о том, чтобы дополнительная информация была 
  абсолютно случайной и непрогнозируемой. Но так же и о том, чтобы дополнительные блоки помогали определить был ли шифротекст получен в результате работы 
  шифрующей функции или он смоделирован злоумышленником. Причем в случае, если будет обнаружено, что шифротекст смоделирован вместо расшифрованных данных 
  атакующему будет выдано сообщение о несоответствие данных реальному криптотексту.

  В \textit{RSA} при подписи и при шифровании данных используют две различные схемы дополнений. Схема, реализуемая для подписания документов, называется 
  \textit{RSA-PSS(probabilistic signature scheme)} или вероятностная схема подписи. Схема, используемая при шифровании – 
  \textit{RSA-OAEP(Optimal asymmetric encryption padding)} или оптимизированное асимметричное дополнение шифрования, на примере \textit{OAEP} и рассмотрим 
  как на самом деле происходит шифрование сообщений в \textit{RSA}.

  И так чтобы зашифровать абсолютно любое сообщение в \textit{RSA-OAEP} делается следующее: \\*
  Выбираются две хеш-функции {$G(x)$} и {$H(x)$} таким образом, чтобы суммарная длина результатов хеш-функций не превышала длины ключа \textit{RSA}. Генерируется случайная строка битов \textit{l}. Длина строки должна быть равна длине результата хеш-функции {$H(x)$}.

    \begin{enumerate}
	    \item Выбираются две хеш-функции {$G(x)$} и {$H(x)$} таким образом, чтобы суммарная длина результатов хеш-функций не превышала длины 
	      ключа \textit{RSA}.
	    \item Генерируется случайная строка битов {$l$}. Длина строки должна быть равна длине результата хеш-функции {$H(x)$}.
	    \item Сообщение {$M$} разбивают на блоки по \textit{{$k$}-бит}. Затем к каждому полученному блоку {$m$} дописывают {$(n-k)$} нулей. 
	      Где \textit{{$n$}-длина} хеш-функции {$G(x)$}.
	    \item Определяют следующий набор бит: {$ \{m||0^{(n-k)} \oplus G(l)\}||\{l \oplus H(m||0^{(n-k)} \oplus G(l))\} $}
	    \item Полученные биты представляют в виде целого числа {$M_1$}
	    \item Криптотекст получают по формуле: {$ C=M_{1}^{e}(mod n) $}
    \end{enumerate}

  Процесс дешифрования выглядит следующим образом:
    \begin{enumerate}
	    \item Находят {$M_1$} по формуле \textit{$ M_{1}=C^{d}(mod n) $}
	    \item В полученном наборе бит отсекают левую часть. В смысле: левой частью служат {$n$} левых бит числа {$M_1$}, где {$n$}-длина 
	      хеш-функции {$G(x)$}. Обозначим эти биты условно {$T$}. И заметим, что {$T= \{m||0^{(n-k)} \oplus G(l)\} $}. Все 
	      остальные биты являются правой частью.
	    \item Находим {$ H(T)=H(m||0^{(n-k)} G(l)) $}
	    \item Зная {$H(T)$} получаем {$l$}, поскольку знаем {$l \oplus H(T)$} -это правая часть блока
	    \item Вычислив {$l$}, находим {$m$} из {$T \oplus G(l)$}, поскольку {$ T=\{m||0^{(n-k)} \oplus G(l)\} $}
	    \item Если {$m$} заканчивается {$(n-k)$}-нулями значит сообщение зашифровано правильно. Если нет то это значит, что шифротекст 
	      некорректен, а следовательно он скорее всего подделан злоумышленником.
    \end{enumerate}

  Таким образом \textit{RSA} это не только возведение в степень по модулю большого числа. Это еще и добавление избыточных данных позволяющих реализовать 
  дополнительную защиту вашей информации. Вы, возможно, спросите: а зачем это все нужно? Неужели в действительности может произойти такая ситуация, когда 
  атакующий получит доступ к расшифровывающему алгоритму? Совсем по другому поводу как-то было сказано: если какая-либо неприятность может произойти, она 
  обязательно произойдет.