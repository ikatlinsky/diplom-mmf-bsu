\section{Основы RSA}

\paragraph{} Пусть \textit{n} и \textit{e} натуральные числа. Функция \textit{f} реализующая схему RSA, устроена следующим образом
\begin{equation}
  \textit{f : x {$\rightarrow$} x\textsuperscript{e} (mod n)},
\end{equation}
Для расшифровки сообщения \textit{a = f(x)} достаточно решить сравнение 

\begin{equation}
  \textit{x\textsuperscript{e} = a (mod n)} 
\end{equation}
При некоторых условиях на \textit{n} и \textit{e} это сравнение имеет единственное решение \textit{x}.

  Для того, чтобы описать эти условия и объяснить, как можно найти решение, нам потребуется одна теоретико-числовая функция - функция Эйлера. 
Эта функция натурального аргумента \textit{n} обозначается \textit{{$\varphi$}(n)} и равняется количеству целых чисел на отрезке от 1 до \textit{n}, 
взаимно простых с \textit{n}. Так \textit{{$\varphi$}(1) = 1} и \textit{{$\varphi$}(p\textsuperscript{ r}) = p\textsuperscript{ r - 1}(p - 1)} 
для любого простого числа \textit{p} и натурального \textit{r}. Кроме того, \textit{{$\varphi$}(a b) = {$\varphi$}(b) {$\varphi$}(a)} 
для любых натуральных взаимно простых \textit{a} и \textit{b}. Эти свойства позволяют легко вычислить значение \textit{{$\varphi$}(n)}, если известно 
разложение числа \textit{n} на простые сомножители. 

  Если показатель степени \textit{e} в сравнении (3.1.2) взаимно прост с \textit{{$\varphi$}(n)}, то сравнение (3.1.2) имеет единственное решение. 
Для того, чтобы найти его, определим целое число \textit{d}, удовлетворяющее условиям. 
\begin{equation}
 \textit{d e {$\equiv$} (mod {$\varphi$}(n)), 1 {$\leq$} d {$<$} {$\varphi$}}.
\end{equation}
Такое число существует, поскольку \textit{(e, {$\varphi$}(n)) = 1}, и притом единственно. Здесь и далее символом \textit{(a, b)} будет обозначаться 
наибольший общий делитель чисел \textit{a} и \textit{b}. Классическая теорема Эйлера, утверждает, что для каждого числа \textit{x}, взаимно простого 
с \textit{n}, выполняется сравнение \textit{x\textsuperscript{ {$\varphi$}(n)} {$\equiv$} 1 (mod n) } и, следовательно
\begin{equation}
 \textit{a\textsuperscript{ d} {$\equiv$} x\textsuperscript{ d e} {$\equiv$} x (mod n)}.
\end{equation}
Таким образом, в предположении \textit{(a, m) = 1}, единственное решение сравнения (3.1.2) может быть найдено в виде
\begin{equation}
 \textit{x {$\equiv$} a\textsuperscript{ d} (mod n)}.
\end{equation}
Если дополнительно предположить, что число \textit{n} состоит из различных простых сомножителей, то сравнение (3.5) будет выполняться и без 
предположения \textit{(a, m) = 1}. Действительно, обозначим \textit{r = (a, n)} и \textit{s = {$\frac{n}{r}$}}. Тогда {$\varphi$}(n) делится на {$\varphi$}(r), 
а из (3.2) следует, что \textit{(x, s) = 1}. Подобно (3.4), теперь легко находим (3.5). А кроме того, имеем \textit{x {$\equiv$} 0 {$\equiv$} a\textsuperscript{ r} (mod r)}. 
Получившиеся сравнения в силу \textit{(r, s) = 1} дают нам (3.5).

  Функция (3.1), принятая в системе RSA, может быть вычислена достаточно быстро. Обратная к \textit{f(x)} функция 
\textit{f\textsuperscript{ -1} : x {$\rightarrow$} x\textsuperscript{ d} (mod n) } вычисляется по тем же правилам, что и \textit{f(x)}, 
лишь с заменой показателя степени \textit{e} на \textit{d}.

  Для вычисления функции (3.1) достаточно знать лишь числа \textit{e} и \textit{n}. Именно они составляют открытый ключ для шифрования. 
А вот для вычисления обратной функции требуется знать число \textit{d}. Казалось бы, ничего не стоит, зная число \textit{n}, разложить 
его на простые сомножители, вычислить затем с помощью известных правил значение \textit{{$\varphi$}(n)} и, наконец, с помощью (3.3) определить 
нужное число \textit{d}. Все шаги этого вычисления могут быть реализованы достаточно быстро, за исключением первого. Именно разложение числа \textit{n} на 
простые множители и составляет наиболее трудоемкую часть вычислений. В теории чисел несмотря на многолетнюю её историю и на очень интенсивные поиски в течение последних 20 лет, 
эффективный алгоритм разложения натуральных чисел на множители так и не найден.

  Авторы схемы RSA предложили выбирать число \textit{n} в виде произведения двух простых множителей \textit{p} и \textit{q}, примерно одинаковых по 
величине. Так как 
\begin{equation}
 \textit{{$\varphi$}(n) = {$\varphi$}(p q) = (p-1)(q-1)},
\end{equation}
то единственное условие на выбор показателя степени \textit{e} в отображении (1) есть
\begin{equation}
 \textit{(e, p - 1) = (e, q - 1) = 1}
\end{equation}

  Итак, лицо, заинтересованное в организации шифрованной переписки с помощью схемы RSA, выбирает два достаточно больших простых числа \textit{p} и \textit{q}. 
Перемножая их, оно находит число \textit{n = p q}. Затем выбирается число \textit{e}, удовлетворяющее условиям (3.7), вычисляется с помощью (3.6) 
число \textit{{$\varphi$}(n)} и с помощью (3.3) - число \textit{d}. Числа \textit{n} и \textit{e} публикуются, число \textit{d} остается секретным. 

  Для иллюстрации своего метода Ривест, Шамир и Адлеман зашифровали таким способом некоторую английскую фразу. Сначала она стандартным образом 
(а=01, b=02, .... z=26, пробел=00) была записана в виде целого числа \textit{x}, а затем зашифрована с помощью отображения (3.1) при
\begin{center}
 \textit{m=11438162575788886766932577997614661201021829672124236256256184293570 6935245733897830597123563958705058989075147599290026879543541}
\end{center}
и 
\begin{center}
 \textit{e=9007}.
\end{center}
Эти два числа были опубликованы, причем дополнительно сообщалось, что \textit{n = p q}. где \textit{p} и \textit{q} - простые числа, записываемые 
соответственно 64 и 65 десятичными знаками. 

  Сложность алгоритмов теории чисел обычно принято измерять количеством арифметических операций (сложений, вычитаний, умножений и делений с остатком), 
необходимых для выполнения всех действий, предписанных алгоритмом. Впрочем, это определение не учитывает величины чисел, участвующих в вычислениях. 
Ясно, что перемножить два стозначных числа значительно сложнее, чем два однозначных, хотя при этом и в том, и в другом случае выполняется лишь одна 
арифметическая операция. Поэтому иногда учитывают ещё и величину чисел, сводя дело к так называемым битовым операциям, т. е. оценивая количество 
необходимых операций с цифрами 0 и 1, в двоичной записи чисел.
Говоря о сложности алгоритмов, мы будем иметь в виду количество арифметических операций. При построении эффективных алгоритмов и обсуждении верхних 
оценок сложности обычно хватает интуитивных понятий той области математики, которой принадлежит алгоритм. Формализация же этих понятий требуется лишь 
тогда, когда речь идёт об отсутствии алгоритма или доказательстве нижних опенок сложности.
Приведем теперь примеры достаточно быстрых алгоритмов с опенками их сложности. Здесь и в дальнейшем мы не будем придерживаться формального описания 
алгоритмов, стараясь в первую очередь объяснить смысл выполняемых действий.

\subsection{Алгоритм создания ключей, шифрования и дешифрования}

  \subsubsection{Алгоритм создания открытого и секретного ключей}
  RSA-ключи создаются следующим образом:
  
    \begin{enumerate}
     \item Выбираются 2 различных случайных простых числа \textit{p} и \textit{q} заданного размера (например, 1024 бита каждое)
     \item Вычисляется их произведение \textit{N = p q}, которое называется модулем
     \item Вычисляется значение функции Эйлера от числа \textit{N}: \textit{{$\varphi$}(N) = (p - 1)(q - 1)}
     \item Выбирается целое число \textit{e} такое, что \textit{1 < e < {$\varphi$}(N)}, взаимно простое со значением функции \textit{{$\varphi$}(N)}, 
     число \textit{e} называется экспонентой
     \item Вычисляется число \textit{d}, мультипликативно обратное к числу \textit{e} по модулю \textit{{$\varphi$}(N)}, то есть число, удовлетворяющее 
     условию: \textit{d e {$\equiv$} 1(mod {$\varphi$}(N))}, а именно \textit{d {$\equiv$} e\textsuperscript{-1} (mod {$\varphi$}(N))}, число \textit{d} 
     называется секретной экспонентой
     \item Пара \textit{\{e, n\}} публикуется в качестве открытого ключа
     \item Пара \textit{\{d, n\}} играет роль закрытого ключа и держится в секрете
    \end{enumerate}

  \subsubsection{Алгоритм шифрования}
  Пусть абонент \textit{B} зашифровывает и посылает \textit{A} сообщение \textit{m}, которое тот затем расшифровывает, тогда \textit{B} должен сделать:
  
    \begin{enumerate}
     \item Получить открытый ключ \textit{A}: \textit{\{e, N\}}
     \item Представить сообщение в виде числа \textit{m} из интервала \textit{[0, N - 1]}
     \item Вычислить \textit{c = m\textsuperscript{e} (mod N)}
     \item Послать шифртекст с абоненту \textit{A}
    \end{enumerate}
  
  \subsubsection{Алгоритм дешифрования}
  Для получения текста A должен сделать:
    
    \begin{enumerate}
     \item Используя секретный ключ \textit{d} вычислить \textit{m = c\textsuperscript{d}(mod N)}.
    \end{enumerate}  
    
  \begin{theorem}
    \textit{Если ed {$\equiv$} 1(mod {$\varphi$}(N)), (e, {$\varphi$}(N)) = 1, (m, N)=1, тогда (m\textsuperscript{e})\textsuperscript{d} (mod N) = m}
  \end{theorem}
