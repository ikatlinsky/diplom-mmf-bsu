% !TEX root = ../DiplomProject.tex

\section{Основные алгоритмы RSA}
 
\begin{comment}
  Для иллюстрации своего метода Ривест, Шамир и Адлеман зашифровали таким способом некоторую английскую фразу. Сначала она стандартным образом 
(а=01, b=02, .... z=26, пробел=00) была записана в виде целого числа $x$, а затем зашифрована с помощью отображения (3.1) при
\begin{center}
 $m=11438162575788886766932577997614661201021829672124236256256184293570 6935245733897830597123563958705058989075147599290026879543541$
\end{center}
и 
\begin{center}
 $e=9007$.
\end{center}
Эти два числа были опубликованы, причем дополнительно сообщалось, что $n = p q$. где $p$ и $q$ - простые числа, записываемые 
соответственно 64 и 65 десятичными знаками. 

  Сложность алгоритмов теории чисел обычно принято измерять количеством арифметических операций (сложений, вычитаний, умножений и делений с остатком), 
необходимых для выполнения всех действий, предписанных алгоритмом. Впрочем, это определение не учитывает величины чисел, участвующих в вычислениях. 
Ясно, что перемножить два стозначных числа значительно сложнее, чем два однозначных, хотя при этом и в том, и в другом случае выполняется лишь одна 
арифметическая операция. Поэтому иногда учитывают ещё и величину чисел, сводя дело к так называемым битовым операциям, т. е. оценивая количество 
необходимых операций с цифрами 0 и 1, в двоичной записи чисел.
Говоря о сложности алгоритмов, мы будем иметь в виду количество арифметических операций. При построении эффективных алгоритмов и обсуждении верхних 
оценок сложности обычно хватает интуитивных понятий той области математики, которой принадлежит алгоритм. Формализация же этих понятий требуется лишь 
тогда, когда речь идёт об отсутствии алгоритма или доказательстве нижних опенок сложности.
Приведем теперь примеры достаточно быстрых алгоритмов с опенками их сложности. Здесь и в дальнейшем мы не будем придерживаться формального описания 
алгоритмов, стараясь в первую очередь объяснить смысл выполняемых действий.
\end{comment}
\subsection{Алгоритм создания ключей, шифрования и дешифрования}

  \subsubsection{Алгоритм создания открытого и секретного ключей}
  RSA-ключи создаются следующим образом - \cite[Глава 9, страницы 148-155]{tilb06}:
  
    \begin{enumerate}
     \item Выбираются 2 различных случайных простых числа $p$ и $q$ заданного размера (например, 1024 бита каждое), для этого
      можно воспользоваться \textit{теоремой Диемитко} (2.2.1).
     \item Вычисляется их произведение $N = p q$, которое называется модулем.
     \item Вычисляется значение функции Эйлера от числа $N$: $\varphi(N) = (p - 1)(q - 1)$.
     \item Выбирается целое число $e$ такое, что $1 < e < \varphi(N)$, взаимно простое со значением функции $\varphi(N)$, 
     число $e$ называется экспонентой.
     \item Вычисляется число $d$, мультипликативно обратное к числу $e$ по модулю $\varphi(N)$, то есть число, удовлетворяющее 
     условию: $d e \equiv 1(mod \: \varphi(N))$, а именно $d \equiv e^{-1} (mod \: \varphi(N))$, число $d$ 
     называется секретной экспонентой, можно воспользоваться \textit{расширенным алгоритмом Евклида} \cite[Глава 1.8, страницы 23-25]{ish11}.
     \item Пара $\{e, n\}$ публикуется в качестве открытого ключа.
     \item Пара $\{d, n\}$ играет роль закрытого ключа и держится в секрете.
    \end{enumerate}

  \subsubsection{Алгоритм шифрования}
  Пусть абонент $B$ зашифровывает и посылает $A$ сообщение $m$, которое тот затем расшифровывает, тогда $B$ должен сделать
  - \cite[Глава 9, страницы 148-155]{tilb06}:
  
    \begin{enumerate}
     \item Получить открытый ключ $A$: $\{e, N\}$.
     \item Представить сообщение в виде числа $m$ из интервала $[0, N - 1]$.
     \item Вычислить $c \equiv m^{e} (mod \: N)$.
     \item Послать шифртекст с абоненту $A$.
    \end{enumerate}
  
  \subsubsection{Алгоритм дешифрования}
  Для получения текста $A$ должен сделать - \cite[Глава 9, страницы 148-155]{tilb06}:
    
    \begin{enumerate}
     \item Используя секретный ключ $d$ вычислить $m \equiv c^{d} (mod \: N)$.
    \end{enumerate}  
    
  \begin{theorem}
    Если $ed \equiv 1(mod \: \varphi(N))$, $(e, \varphi(N)) = 1$, $(m, N)=1$, тогда $(m^{e})^{d} (mod \: N) = m$

    \begin{proof}
      Поскольку $ed \equiv 1(mod \: \varphi(N))$ , значит $ed = 1 + k \varphi(N)$, где $k$ - некоторое число. Из теоремы Эйлера следует,
      что 
        \begin{equation}
          m^{\varphi(N)} \equiv 1(mod \: N), (m, N) = 1.
        \end{equation}
      Значит $(m^e)^d (mod \: N) = m^{1 + k \varphi(N)}(mod \: N) = m (m^{\varphi(N)})^k (mod \: N) = m$.
    \end{proof}
  \end{theorem}