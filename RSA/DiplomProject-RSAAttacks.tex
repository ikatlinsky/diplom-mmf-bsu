\section{Атаки на RSA}

\subsection{Relaxed RSA problem}

\paragraph{} Проблемой RSA является задача обращения функции RSA. Имея {$m^e (mod N)$} необходимо найти уникальный {$e$}-ый корень {$m \in Z_N$}, 
  предполагается, что эту задачу сложно решить для произвольного {$m$}, однако проблема является тривиальной для малых {$m$} и {$e$}. А именно, если
  {$m < N^\frac{1}{e}$}, тогда {$m^e (mod N) = m^e$} над {$Z$}.
  
  \subsubsection{Проблема RSA}
  Дано: {$m^e (mod N)$} \\   
  Найти: {$m \in Z_N$}
  
\paragraph{} Копперсмит расширил этот результат на случай, когда {$m$} не является малым, но мы знаем {$m$} с некоторой точностью. Точнее, мы знаем аппроксимацию
  {$m'$} такую, что {$m = m' + x_0$} для неизвестного {$x_0$}: {$|x_0| \le N^\frac{1}{e}$}. Это утверждение можно представить в виде полинома
  
    \begin{equation}
     \textit{{$ f(x) = (m' + x)^e - m^e (mod N) $}}.
    \end{equation}
    
  \subsubsection{Relaxed проблема RSA}
  Дано: {$m^e, m', |m-m'| \le N^\frac{1}{e}$} \\   
  Найти: {$m \in Z_N$}  
  
\paragraph{} Применим \textit{теорему Копперсмита (3.2.6)} с параметрами {$\beta = 1, \delta = e, c = 1$}. Это расширяет атаку в тривиальном случае, где {$m$} малое. Этот
  результат можно интерпретировать следующим образом: если {$e = 3$}, тогда злоумышленник, который знает 2/3 сообщения, может узнать оставшуюся
  1/3 часть сообщения {$m$} за полиномиальное время. Это может случиться при использовании шаблонных сообщений вида "Сегодня пароль: xxxx", часть 
  "Сегодня пароль:" повторяется каждый раз, поэтому злоумышленник легко сможет вычислить пароль.
\subsection{Атака Франклина-Райтера}

\paragraph{} Предположим, что у нас есть открытый ключ RSA, принадлежащий A. Атака \textit{Франклина-Рейтера} применяется в следующей ситуации. B хочет отправить A два шифрованных 
  сообщения \textit{{$m_1$}} и \textit{{$m_2$}}, связанных друг с другом с помощью следующего открытого многочлена \textit{{$ m_2 = f(m_1)(mod n) $}}
  
  По соответствующим шифротекстам \textit{{$c_1$}} и \textit{{$c_2$}} нападающий имеет хорошие шансы раскрыть сообщения \textit{{$m_1$}} и \textit{{$m_2$}} при любой небольшой
  шифрующей экспоненте \textit{e}. Атака наиболее проста, если \textit{f = aх + b} и \textit{e = 3}, причем \textit{a} и \textit{b} фиксированы и известны атакующему. 
  Нападающий знает, что \textit{{$m_2$}} - корень по модулю \textit{n} многочленов
  
    \begin{equation}
      \textit{{$ g_1(x) = x^3 - c_2 g_2(x) = (f(x))^3 - c_1 $}}
    \end{equation}

  Поэтому линейная функция \textit{{$х - m_2$}} делит как \textit{{$ g_1(x) $}}, так и \textit{{$ g_2(x) $}}.
  
  Можно показать, что в случае \textit{f = aх + b} и \textit{e = 3} искомый наибольший общий делитель (если таковой существует) должен быть линейным множителем 
  многочлена \textit{{$x - m_2$}}, то есть совпадать с ним. Значит, нападающий найдет \textit{{$m_2$}}, а затем \textit{{$m_1$}}.
  
  Обобщение \textit{Копперсмита} атаки \textit{Франклина-Рейтера} строится по пути, на котором можно получить дополнительный результат из атаки Хастадта. Предположим, что сообщение \textit{m} 
  перед шифрованием пополняется некоторыми случайными данными. Например, если \textit{n} - \textit{n-битовый} модуль \textit{RSA}, а \textit{m} - \textit{k-битовое} сообщение, 
  то можно добавить \textit{n - k} случайных битов либо в начало, либо в конец сообщения. Пусть \textit{{$ m' = 2\textsuperscript{n-k}m + r $}}, где \textit{r} - зависящее от 
  \textit{m} случайное число длины \textit{n - k}. Копперсмит показал, что такое пополнение сообщения нестойко.
  
  Предположим, что B дважды посылает одно сообщение A, то есть возникает два шифротекста \textit{{$ m_1 = 2\textsuperscript{n-k}m + r_1 $}} и
  \textit{{$ m_2 = 2\textsuperscript{n-k}m + r_2 $}} соответствующих сообщениям где \textit{{$r_1$}} и \textit{{$r_2$}} - два разных случайных числа, состоящие из 
  \textit{n - k} битов. Атакующий вводит обозначение \textit{{$ y_0 = r_2 - r_1 $}} и пытается решить
  систему уравнений
  
    \begin{equation}
	  \begin{cases}
	    g_1(x,y) &= x^e - c_1 \\
	    g_2(x,y) &= (x+y)^e - c_2
	  \end{cases}    
      \end{equation}
      
  Он вычисляет результант \textit{h(y)} многочленов \textit{{$g_1(x,y)$}} и \textit{{$g_2(x,у)$}} относительно переменной \textit{х}. Теперь \textit{{$y_0$}} -
  маленький корень многочлена \textit{h(y)} степени \textit{{$e^2$}}. Опираясь на \textit{теорему Копперсмита (3.2.6)}, нападающий находит разность \textit{{$r_2 - r_1$}} и 
  узнает \textit{{$m_2$}}, используя метод \textit{атаки Франклина-Рейтера}.

\subsection{Расширенная атака Хастаадта}

\paragraph{} Предположим, что мы хотим транслировать простое RSA зашифрованное сообщение к группе из {$k$} получателей, которые имеют публичные
  экспоненты {$e$} и взаимно простые модули {$N_1, \dots, N_k$}. То есть, мы отправляем сообщения {$m^e (mod N_1), \dots, m^e (mod N_k)$}. 
  Исходя из этой информации, злоумышленник может вычислить {$m^e (mod \prod_{i=1}^{k}{N_I})$}. Если {$m^e$} меньше, чем произведение модулей, то он 
  может вычислить {$m$} по {$e$}-му корню над целыми числами. Если все {$N_i$} имеют одинаковые размерности, то необходимо {$k > e$} сообщений,
  чтобы вычислить {$m$}.
  
  Предполагая, что сообщения {$m$} меньше {$min_j \{ N_j \}$}, обрабатываем их используя известные полиномиальные отношения {$g_1, \dots, g_k$}
  со степенями {$\delta_1, \dots, \delta_k$} соответственно.
  
  Применяя \textit{теорему Копперсмита (3.2.6)} с параметрами {$\beta,c=1$} мы можем найти все корни {$m$}, удовлетворяющие ограничению
  {$m \le N^\frac{1}{\delta} = \prod_{i=1}^{k}{N\textsuperscript{{$\frac{1}{\delta_i e_i}$}}_i}$}.

\subsection{Factoring with High Bits Known}

\paragraph{} Пусть {$N = pq$}, {$p > q$}. Предположим, что мы знаем наиболее важные биты числа {$p$}. Наша задача найти факторизацию числа
  {$N$} за полиномиальное время.
  
  В 1985, Риверст и Шамир опубликовали алгоритм, который факторизует {$N$} зная {$\frac{2}{3}$} битов числа {$p$}. Копперсмит улучшил этот результат
  до {$\frac{3}{5}$} в 1995. Годом позже он опубликовал алгоритм, который использовал {$\frac{1}{2}$} битов числа {$p$}.
  
  Проблему разложения чисел при знании битов одного из чисел разложения также можно свести к проблеме решения одномерного полиномиального
  уравнения, используя \textit{LLL-алгоритм}. Предположим нам известна половина битов числа {$p$}, тогда нам известна аппроксимация {$p'$}
  числа {$p$} такая, что {$|p-p'| \le N^\frac{1}{4}$}.
  
  \subsubsection{Проблема факторизации}
  Дано: {$N = p q$} \\   
  Найти: {$p$}  
  
  \subsubsection{Relaxed проблема факторизации}
  Дано: {$ N = p q, p': |p-p'| \le N^\frac{1}{4} $} \\   
  Найти: {$p$}  
  
  Наша цель - найти недостающие биты числа {$p$}, то есть мы хотим найти корни одномерного, линейного полинома
  
    \begin{equation}
     \textit{{$ f(x) = p' + x (mod p) $}}.
    \end{equation}

  Заметим, что {$p-p'$} является корнем {$f(x)$} при абсолютных значениях меньших, чем {$N^\frac{1}{4}$}.
  
  Применим \textit{теорему Копперсмита (3.2.6)} с полиномом {$f(x) = p' + x$}, то есть с параметрами {$\delta = 1, \beta = \frac{1}{2}, c = 1$}.
  Кроме того, мы можем найти все корни {$x_0$} размерности
  
    \begin{equation}
     \textit{{$ |x_0| \le N^\frac{\beta^2}{\delta} = N^\frac{1}{4}$}}.
    \end{equation}
    
  Эти рассуждения и действия позволям нам найти недостающие биты числа {$p$} за полиномиальное время с использованием \textit{LLL-алгоритма}
  и \textit{теоремы Копперсмита (3.2.6)}, а значит решить проблемы факторизации числа {$N$}.
\subsection{Атака Винера}

\paragraph{} Мы уже отмечали, что в алгоритме \textit{RSA} для ускорения операций с открытым ключом используют малые шифрующие экспоненты. В некоторых же 
  приложениях этой криптосистемы существеннее ускорить процессы расшифровывания. Поэтому имеет смысл выбирать небольшую расшифровывающую экспоненту
  \textit{d}. Ясно, что при этом получается большое значение открытой экспоненты \textit{e}. Слишком маленькое число в качестве секретной экспоненты \textit{d} мы 
  брать не можем, поскольку атакующий определит ее простым перебором. Более того, учитывая атаку Винера, опирающуюся на непрерывные дроби,
  необходимо выбирать \textit{d} среди чисел, размер которых не меньше, чем \textit{{$ \frac{1}{3} N^\frac{1}{4} $}}
  
  По вещественному числу \textit{{$ \alpha \in R $}} определим последовательности:
  
  \begin{subequations}
      \begin{center}
	\textit{{$ \alpha_0 = \alpha, p_0 = q_0 = 1, p_1 = a_0 a_1 + 1, q_1 = a_1 $}},\\
	\textit{{$ a_i = \lfloor \alpha_i \rfloor, \alpha\textsubscript{i+1} = \frac{1}{\alpha_i - a_i} $}}, \\
	\textit{{$ p_i = a_i p\textsubscript{i-1} + p\textsubscript{i-2}, q_i = a_i q\textsubscript{i-1} + q\textsubscript{i-2}, i \ge 2$}},
      \end{center}
  \end{subequations}
  
  Целые числа \textit{{$ \alpha_0, \alpha_1, \alpha_2, \dots $}} называются непрерывной дробью, представляющей \textit{{$\alpha$}}, а рациональные числа \textit{{$ \frac{p_i}{q_i} $}}
  - подходящими дробями. Каждая из подходящих дробей несократима, а скорость роста их знаменателей сравнима с показательной.
  
  Одним из важных результатов теории непрерывных дробей является то, что если несократимая дробь удовлетворяет неравенству:
  
    \begin{equation}
	\textit{{$ | \alpha - \frac{p}{q} | \le \frac{1}{2 q^2} $}},
    \end{equation}

  то \textit{{$ \frac{p}{q} $}} - одна из подходящих дробей в разложении \textit{{$\alpha$}} в непрерывную дробь.
  
  Винер предлагает использовать непрерывные дроби при атаке на \textit{RSA} следующим образом. Пусть у нас есть модуль \textit{N = p q}, причем \textit{q < р < 2q}. 
  Допустим, что наша расшифровывающая экспонента удовлетворяет неравенству \textit{{$d < \frac{1}{3} N^\frac{1}{4} $}}, и нападающему это известно. Кроме того, ему дана 
  шифрующая экспонента \textit{e}, обладающая свойством 
  
    \begin{equation}
      \textit{{$ e d = 1 (mod \phi), \phi = \phi(N) = (p - 1)(q - 1) $}}
    \end{equation}
  
  Будем также считать, что \textit{{$e < \phi$}}, поскольку это выполнено в большинстве приложений. Заметим, из предположений следует существование такого целого \textit{k}, что
  \textit{{$e d - k \phi = 1$}}. Следовательно,
  
    \begin{equation}
     \textit{{$ |\frac{e}{\phi} - \frac{k}{d}| = \frac{1}{d \phi} $}}
    \end{equation}
    
  Поскольку \textit{{$\phi \approx n$}}, получаем, что
  
    \begin{equation}
     \textit{{$ |n - \phi| = |p + q - 1| < 3 \sqrt{n} $}}
    \end{equation}

  Отсюда можно сделать вывод, что \textit{{$ \frac{e}{n} $}} - довольно хорошее приближение в \textit{{$ \frac{k}{d} $}}. Действительно,
  
    \begin{subequations}
      \begin{center}
	\textit{{$|\frac{e}{n} - \frac{k}{d}| = |\frac{e d - n k}{d n}| = |\frac{e d - k \phi - n k + k \phi}{d n}| = $}} \\
	\textit{{$= |\frac{1 - k(n - \phi)}{d n}| \le |\frac{3 k \sqrt{n}}{d n}| = |\frac{3 k}{d \sqrt{n}}|$}}
      \end{center}
    \end{subequations}
    
  Поскольку \textit{{$e < \phi$}}, очевидно, \textit{k < d}. Кроме того, по предположению \textit{{$d < \frac{1}{3} N^\frac{1}{4} $}}. Значит, 
  \textit{{$ |\frac{e}{n} - \frac{k}{d}| < \frac{1}{2 d^2} $}}
  
  Поскольку \textit{НОД(k, d) = 1}, мы видим, что - подходящая дробь в разложении дробив непрерывную. Таким образом, раскладывая числов непрерывную дробь, можно узнать 
  расшифровывающую экспоненту, поочередно подставляя знаменатели подходящих дробей в выражение \textit{{$(M^e)^d = М (mod n)$}} для некоторого случайного числа \textit{М}. 
  Получив равенство, найдем \textit{d}. Общее число подходящих дробей, которое нам придется при этом проверить, оценивается как \textit{О(ln n)}. 
  Таким образом, изложенный метод дает линейный по сложности алгоритм определения секретного ключа в системе \textit{RSA}, если последний не превосходит 
  \textit{{$\frac{1}{3} N^\frac{1}{4} $}}
  
  \begin{example}
    В качестве примера рассмотрим модуль RSA, равный \textit{n = 9449868410449}. Пусть открытый ключ криптосистемы задан как \textit{e = 6792605526025},
    а секретный ключ удовлетворяет неравенству \textit{d = 584}. Разложим число \textit{{$ \alpha = \frac{e}{n} $}} непрерывную дробь и проверим знаменатель каждой 
    подходящей дроби: не является ли он секретным ключом. Подходящие дроби разложения \textit{{$ \alpha $}} имеют вид:
    
      \begin{equation}
	\textit{{$ 1, \frac{2}{3}, \frac{3}{4}, \frac{5}{7}, \frac{18}{25}, \frac{23}{32}, \frac{409}{569}, \frac{1659}{2308}, \dots$}}
      \end{equation}

    Поочередно проверяя знаменатели, убедимся, что \textit{d = 569}, то есть знаменатель седьмой подходящей дроби - искомый секретный ключ.
  \end{example}
  
  
\subsection{Выводы}

\paragraph{} Изобретение \textit{LLL-алгоритма} стало базисом и отправной точкой для создания эффективного алгоритма и \textit{теоремы Копперсмита}, которые
  решают проблему поиска малых решений для полиномиальных уравнений. Это открыло совершенно новую линию исследований и новые направления решения
  сложных проблем, такие как проблема факторизации, позволила рассматривать вопросы под совершенно новым углом. По сравнению с
  традиционными методами, такими как \textit{метод эллиптических кривых}, \textit{метод решета числового поля}, \textit{LLL-алгоритм} работает за полиномиальное время,
  однако способен решать лишь приближенные задачи факторизации для \textit{RSA}.
  
  Сегодня, \textit{relaxed методы} все еще далеки от желаемого результата и эффективности и по нетором позициям проигрывают традиционным методам,
  однако наблюдается устойчивый прогресс в поиске новых приложений, методов и вариаций алгоритмов, улучшаются результаы, все больше ограничений
  снимается. С исследовательской точки зрения еще довольно новый метод поиска решений, базирующийся на LLL-методе, представляет большой интерес,
  содержит в себе много результатов, которые будут открыты.
  
  Для больших \textit{n} с большими простыми множителями разложение на множители является серьезной проблемой, но не настолько, как требуется. 
  Поразительной иллюстрацией этого может служить следующая история. В 1977 году три изобретателя алгоритма\textit{RSA} отважились предложить читателям 
  популярного журнала раскрыть шифрованное сообщение. За расшифровку этого сообщения они предложилинаграду в 100 долларов.
  
  По их оценкам, задача не могла быть решена ранее, чем приблизительно через \textit{40 квадрилионов лет}. Но в апреле 1994 года группа пользователей 
  потребовала выплатыпризовой суммы после всего восьми месяцев совместной работы. В предложенной задаче использовался открытый ключ длиной в
  129 десятичных знаков (длина \textit{n}), чторавно примерно 428 битам. Были объявлены конкурсы для шифров с длинами ключей в 100, 110, 120
  и больше знаков. Последней изрешенных задач является задача, для \textit{RSA-130}, в которой длина ключа 
  равна 130 десятичным знакам. Имеющиеся на сегодня результаты показаны в таблице ниже. Единицей мерысложности задачи в данном случае является \textit{MIPS-го}д – 
  объем работы, выполняемой втечение года процессором, осуществляющим обработку одного миллиона команд в секунду, что примерно эквивалентно 
  выполнению {$3\times10^13$} команд.
  
  \begin{table}[ht]
    \begin{tabular}{@{}ccccp{4.5cm}@{}}
    \toprule
    \textbf{Число знаков} & \textbf{Число битов} & \textbf{Дата решения} & \textbf{Число MIPS-лет} & \textbf{Алгоритм} \\ \midrule
    100                              & 332                  & Апрель 1991 г         & 7                       & Квадратичное решето              \\
    110                              & 365                  & Апрель 1992 г.        & 75                      & Квадратичное решето              \\
    120                              & 398                  & Июнь 1993 г.          & 830                     & Квадратичное решето              \\
    129                              & 428                  & Апрель 1994 г.        & 5000                    & Квадратичное решето              \\
    130                              & 431                  & Апрель 1996 г.        & 500                     & Решето в поле чисел общего вида  \\ \bottomrule
    \end{tabular}
  \end{table}
  
  \paragraph{} Известны также более современные результаты факторизации, а именно:  
    \begin{itemize}
      \item Между январем и августом 1999 года с использованием общего метода решета числового поля было факторизовано RSA-155. Вычисления снова производились с 
	привлечением большого количества людей, а финальные вычисления — на суперкомпьютере C916.
      \item В апреле 2003 года Франке и другие объявили о факторизации RSA-160. При разложении использовалось около сотни CPU.
      \item В декабре 2003 Франке, Клеинджанг факторизовали 174-значное число, используя ресурсы BSI и Боннского университета.
      \item В мае 2005 176-значный сомножель числа 11281 + 1 был найден Аоки, Кида, Шимоямой и Уедой NTT и Риккёский Университет в Японии.
    \end{itemize}
  
  Угроза ключам большой длины здесь двойная: непрерывный рост вычислительной мощи современных компьютеров и непрерывное 
  усовершенствование алгоритмов разложения на множители.



