\section{Криптоанализ RSA}

  \paragraph{} Стойкость RSA основывается на проблеме факторизации больших простых чисел. Действительно, если злоумышленнику удастся разложить
  \textit{N} на делители \textit{p} и \textit{q}, то для него не составит труда вычислить \textit{{$\varphi$}(N)}, а затем определить секретный ключ пользователя. 
  Однако нахождение секретного ключа RSA не эквивалентно проблеме факторизации. Это означает, что \textit{T(RSA) {$\le$} T(факторизации)}, 
  где \textit{T(RSA)} - трудоемкость определения секретного ключа RSA, а \textit{T(факторизации)} - трудоемкость факторизации числа \textit{N}. Тоесть 
  могут быть найдены эффективные алгоритмы определения секретного ключа RSA, причем в то же время проблема факторизации не будет разрешена.
  
  Тремя возможными подходами к криптоанализу алгоритма RSA являются следующие:
  
    \begin{itemize}
     \item Простой перебор. Предполагает проверку всех возможных личных ключей.
     \item Математический анализ. Существует несколько подходов такого рода, но все они по сути эквивалентны нахождению множителей произведения 
     двух простых чисел.
     \item Анализ временных затрат. Опирается на анализ времени выполнения алгоритма дешифрования.
    \end{itemize}
    
  Защита против простого перебора в случае RSA остается той же, что и для всех других криптосистем, – использование большого пространства 
  ключей. С этой точки зрения чем больше битов в \textit{e} и \textit{d}, тем лучше. Однако из-за сложности вычислений как при генерировании 
  ключей, так и при шифровании/дешифровании, чем большим оказывается размер ключа, тем медленнее работает система. В этом разделе для 
  алгоритма RSA мы представ-ляем краткий обзор возможностей его криптоанализа при использовании математического подхода и подхода на основе 
  анализа временных затрат.
  
  Можно выделить следующие три математически различных подхода к криптоанализу RSA:
  
    \begin{itemize}
     \item Разложение \textit{N} на два его простых множителя. Это позволит вычислить \textit{{$\varphi$}(N) = (p - 1)(q - 1)}, на основании чего можно будет 
     определить \textit{{$d = e^-1(mod \varphi(N))$}}.
     \item Определение непосредственно \textit{{$\varphi$}(N)} без того, чтобы сначала определять \textit{p} и \textit{q}. Это также позволит
     определить \textit{{$d = e^-1(mod \varphi(N))$}}.
     \item Определение непосредственно \textit{d} без того, чтобы сначала определять \textit{{$\varphi$}(N)}.
    \end{itemize}
    
  В большинстве случаев обсуждение вопросов криптоанализа шифра RSA касается задачи разложения значения \textit{N} на два его простых множителя. 
  Задача определения \textit{{$\varphi$}(N)} по данному \textit{N} оказывается эквивалентной задаче разложения \textit{N} на множители. Для известных сегодня алгоритмов 
  проблема определения \textit{d} по данным \textit{e} и \textit{N} оказывается требующей по крайней мере таких же затрат времени, как и проблема разложения на 
  множители. Следовательно, затраты на решение задачи разложения на множители можно использовать в качестве эталона при оценке степени 
  защищенности RSA.

\subsubsection{Малая экспонента e}

  \paragraph{} Рассмотрим ситуацию, когда у нас имеется малая экспонента \textit{e} (\textit{e = 3,5,7} и т.д.). Пусть \textit{e = 3}. Допустим, что некто
  \textit{А} желает послать одно и то же сообщение трем другим абонентам, имеющим открытые ключи \textit{{$(3, n_1), (3, n_2), (3, n_3)$}}. А шифрует 
  сообщение и получает \textit{{$c_i = m^3(mod N_i)$}} для \textit{i = 1, 2, 3}. Противник перехватывает все 3 сообщения и составляет систему:
  
    \begin{equation}
	\begin{cases}
	   x &= c_1(mod N_1) \\
	   x &= c_2(mod N_2)\\
	   x &= c_3(mod N_3)
	\end{cases}    
    \end{equation}

  Поскольку \textit{{$0 \le x < N_1 N_2 N_3$}} и \textit{{$m^3 < N_1 N_2 N_3$}}, то по китайской теореме об остатках злоумышленник может найти 
  \textit{{$x = m^3$}} и вычислив кубический корень из \textit{x} найдет \textit{m}. Таким образом получаем, что нельзя использовать малые экспоненты 
  при отправке большого числа одинаковых сообщений. Или же следует использовать добавки в сообщение, в качестве которых могут выступать добавленные в 
  конец сообщения случайные вектора или же время отправки. При использовании малых экспонент также возникает проблема с маленькими сообщениями, то есть 
  с такими, для которых \textit{m < n\textsuperscript{{$\frac{1}{e}$}}}, поскольку в этом случае m может быть получено из шифротекста 
  \textit{{$c = m^e(mod N)$}} путем вычисления корня \textit{e-ой} степени из \textit{c}. Однако использование добавок в сообщение помогает избежать этой 
  проблемы.

\subsubsection{Перебор возможных открытых текстов}

  \paragraph{} Если сообщение не велико, злоумышленник может попытаться подобрать открытый текст путем перебора всех возможных вариантов и 
  шифрования их на открытом ключе абонента \textit{e} до тех пор, пока не будет получен перехваченный шифротекст \textit{c}. Такую атаку также возможно 
  предотвратить при помощи добавок в сообщение

\subsubsection{Использование общих модулей}

  \paragraph{} Схема RSA несостоятельна при использовании общих модулей. Допустим есть 2 абонента \textit{A} и \textit{В} с открытыми ключами 
  \textit{(e\textsubscript{1}, N)} и \textit{(e\textsubscript{2}, N)}. Центр (общий сервер или циркуляр) желает послать обоим абонентам одинаковые сообщения. 
  Он получает \textit{{$m_1\textsuperscript{{$e_1$}} = c_1(mod N)$}} и \textit{{$m_2\textsuperscript{{$e_2$}} = c_2(mod N)$}} и посылает \textit{{$c_1$}} и 
  \textit{{$c_2$}} \textit{А} и \textit{В} соответственно. Противник перехватывает эти сообщения. Затем, если \textit{{$(e_1, e_2) = 1$}}, по 
  расширенному алгоритму Евклида можно найти такие \textit{{$k_1$}} и \textit{{$k_2$}}, для которых \textit{{$e_1 k_1 + e_2 k_2 = 1$}}. И, соответственно, 
  \textit{{$m_1^e k_1 m_2^e k_2 = m$}}. Таким образом найдя такие \textit{{$k_1$}} и \textit{{$k_2$}} противник вычислит 
  \textit{{$c_1\textsuperscript{{$k_1$}} c_2\textsuperscript{{$k_2$}} = m$}}.

\subsubsection{Мультипликативные свойства}

  \paragraph{} Система RSA обладает мультипликативными свойствами. Пусть \textit{{$m_1$}} и \textit{{$m_2$}} - 2 различных открытых текста, а \textit{{$c_1$}}
  и \textit{{$c_2$}} - соответствующие им шифротексты. Заметим, что
  
    \begin{equation}
      \textit{{$(m_1 m_2)^e = m_1^e m_2^e = c_1 c_2 (mod N)$}}
    \end{equation}

  Другими словами, шифротекст открытого текста \textit{{$m = m_1 m_2$}} есть \textit{{$c = c_1 c_2 (mod N)$}}. Это свойство, называемое также гомоморфным 
  свойством  RSA, позволяет осуществить атаку по выбранному шифротексту. Его нужно учитывать при совмещении схем шифрования на основе RSA и цифровой подписи
  RSA.

\subsection{LLL-алгоритм}

  \begin{definition}
    Пусть векторы \textit{{$ b_1, b_2, \dots, d_n \in R^n$}} линейно независимы, \textit{n < m}. Множество 
      \begin{equation}
	\textit{{$L=L(b_1, b_2, \dots, b_n) = Zb_1 + Zb_2 + \dots + Zb_n$}}
      \end{equation}    
    всех целочисленных комбинаций векторов \textit{{$ b_1, b_2, \dots, d_n$}} называется решеткой размерности \textit{n}. Множество
    \textit{{$ \{b_1, b_2, \dots, b_n \} $}} называется базисом решетки \textit{L}.
  \end{definition}
  
  \begin{theorem}
    Пусть {$[b_1, b_2, \dots, b_n]$} - матрица, столбцам которой являются линейно независимые векторы {$ b_1, b_2, \dots, d_n \in R^n$}, {$n \le m$}.
    Векторы \textit{{$ d_1, d_2, \dots, dn \in R^n$}} образуют базис решетки {$L(b_1, b_2, \dots, b_n)$} тогда и только тогда, когда существует такая матрица
    {$M$} размера {$n \times n$} с целыми элементами, {$detM = \pm 1$}, что
    
      \begin{equation}
       \textit{{$[d_1, d_2, \dots, d_n]^T = M [b_1, b_2, \dots, b_n]^T$}}
      \end{equation}

      \begin{proof}
	Доказательство приведено в \cite[Глава 8.2, страница 260]{mah06}
      \end{proof}
  \end{theorem}  

  \begin{definition}
   Определителем решетки {$L(b_1,b_2, \dots, b_n) \in R^n$} называется число
   
   \begin{equation}
    \textit{{$d(L) = \sqrt{detB}, B\textsubscript{ij} = (b_i, b_j)$}}.
   \end{equation}
   Из равенства для скалярного произведения векторов {$(u, v) = u^T E v$}, где \textit{E} - единичная матрица, получаем 
   \textit{{$d(L) = \sqrt{det(B^TEB)} = \sqrt{det(B^TB)}$}}, где {$B = [b_1,b_2, \dots, b_n]$}.
  \end{definition}
  
  \begin{theorem}
   Определитель решетки не зависит от выбора базиса, то есть является инвариантом решетки.
   
   \begin{proof}
    Доказательство приведено в \cite[Глава 8.2, страница 261]{mah06}
  \end{proof}
  \end{theorem}  
  
  Пусть {$\{ b_1, b_2, \dots, b_n \}$} - базис решетки {$L \in R^m$}  пусть числа {$\mu\textsubscript{ij}$}, {$1 \le j < i \le n$}, и векторы
  {$b_1^*, b_2^*, \dots, b_n^*$} получены в результате процесса ортогонализации Грама-Шмидта.
  
  \begin{definition}
   Базис {$\{b_1, b_2, \dots, b_n\}$} называется \textit{LLL-приведенным (приведенным по Ловашу)}, если этот базис приведен по норме и
   
   \begin{equation}
      \textit{{$\lVert b_i^* \lVert^2 \ge (\frac{3}{4} - \mu\textsubscript{{$i,i-1$}}^2)\lVert b^*\textsubscript{{$i-1$}} \lVert^2, 1<i \le m $}}
   \end{equation}

  \end{definition}
  
  \begin{lemma}
   Если {$\{b_1, b_2, \dots, b_n\}$} - \textit{LLL-приведенный} базис решетки {$L \subset R^m$}, то для всех {$1 \le j < i \le n$} выполняется неравенство
   
   \begin{equation}
    \textit{{$ \lVert b_j^* \lVert^2 \le 2\textsuperscript{{$i-j$}} \lVert b_i^* \lVert^2 $}}
   \end{equation}
   \begin{proof}
      Доказательство приведено в \cite[Глава 8.2, страница 265]{mah06}
   \end{proof}   
  \end{lemma}
  
  \begin{theorem}
   Для \textit{LLL-приведенного} базиса {$\{ b_1, b_2, \dots, b_n \}$} решетки {$L \subset R^m$} справедливы следующие утверждения
   
   \begin{enumerate}
    \item \textit{{$ \lVert b_i^* \lVert^2 \le 2\textsuperscript{{$j-1$}} \lVert b_j^* \lVert^2, 1 \le i < j \le n  $}}
    \item \textit{{$ d(L) \le \prod_{i=0}^{n}{ \lVert b_i \lVert } \le 2\textsuperscript{{$\frac{n(n-1)}{4}$}} d(L) $}}
    \item \textit{{$ \lVert b_i \lVert^2 \le 2\textsuperscript{{$\frac{n-1}{4}$}} \sqrt[n]{d(L)} $}}
   \end{enumerate}

   \begin{proof}
      Доказательство приведено в \cite[Глава 8.2, страница 266]{mah06}
   \end{proof}

  \end{theorem}
  
  \subsubsection{Алгоритм Ленстры-Ленстры-Ловаша}
    Вход: Базис {$\{ b_1,b_2, \dots, b_n \}$} решетки в {$R^m$}, {$m \ge n$} \\
    Выход: \textit{LLL-приведенный} базис решетки
  
    \begin{enumerate}
     \item Выполнить процесс ортогонализации Грама-Шмидта для векторов {$b_1, b_2, \dots, b_n$} 
     \item Положить {$k=2$}
     \item При {$ |\mu\textsubscript{{$k,k-1$}}| > \frac{1}{2}$} выполнить следующие действия
     
      \begin{enumerate}
       \item При {$ \mu\textsubscript{{$k,k-1$}} > 0 $} вычислить {$r=[\frac{1}{2} + \mu\textsubscript{{$k,k-1$}}]$}, иначе {$r=-[\frac{1}{2} - \mu\textsubscript{{$k,k-1$}}]$}
       \item Положить {$b_k = b_k - r b\textsubscript{{$k-1$}}$}
       \item Для {$j=1,2,\dots,k-2$} вычислить {$ \mu\textsubscript{{$k,j$}}=\mu\textsubscript{{$k,j$}} - r \mu\textsubscript{{$k-1,j$}} $}
       \item Положить {$ \mu\textsubscript{{$k,k-1$}}=\mu\textsubscript{{$k,k-1$}} - r $}
      \end{enumerate}
     
     \item При {$ B_k < (\frac{3}{4} - \mu^2\textsubscript{{$k,k-1$}})B\textsubscript{{$k-1$}} $} выполнить
     
      \begin{enumerate}
       \item Положить {$\mu = \mu\textsubscript{{$k,k-1$}}$}, {$B=B_k + \mu^2 B\textsubscript{{$k-1$}}$}, {$\mu\textsubscript{{$k,k-1$}}=\frac{\mu B\textsubscript{{$k-1$}}}{B}$},
	{$B_k = \frac{B\textsubscript{{$k-1$}} B_k}{B}$}, {$B\textsubscript{{$k-1$}} = B_k$}
       \item Поменять местами векторы {$b_k$} и {$b\textsubscript{{$k-1$}}$}
       \item При {$k > 2$} поменять местами коэффициенты {$\mu\textsubscript{{$k,j$}}$} и {$\mu\textsubscript{{$k-1,j$}}$} для {$j=1,2,\dots,k-2$}
       \item Для {$s=k+1,k+2,\dots,n$} положить {$t=\mu\textsubscript{{$s,k$}}$}, {$\mu\textsubscript{{$s,k$}}=\mu\textsubscript{{$s,k-1$}}-\mu t$},
	{$\mu\textsubscript{{$s,k-1$}}=t + \mu\textsubscript{{$k,k-1$}} \mu\textsubscript{{$s,k$}}$}
       \item Положить {$k = max(2,k-1)$} и вернуться на шаг 3
      \end{enumerate}
     
     \item При {$ B_k \ge (\frac{3}{4} - \mu^2\textsubscript{{$k,k-1$}})B\textsubscript{{$k-1$}} $} выполнить
     
      \begin{enumerate}
       \item Для {$l=k-2,k-3,\dots,1$} при {$\mu\textsubscript{{$k,j$}}$} выполнить
       
	\begin{enumerate}
	  \item При {$ \mu\textsubscript{{$k,l$}} > 0 $} вычислить {$r=[\frac{1}{2} + \mu\textsubscript{{$k,l$}}]$}, иначе {$r=-[\frac{1}{2} - \mu\textsubscript{{$k,l$}}]$}
	  \item Положить {$b_k=b_k - r b_l$}   
	  \item Для {$j = 1, 2, \dots, l - 1$} положить {$\mu\textsubscript{{$k,j$}} = \mu\textsubscript{{$k,j$}} - r \mu\textsubscript{{$l,j$}}$}
	  \item Положить {$\mu\textsubscript{{$k,j$}} = \mu\textsubscript{{$k,l$}} - r$}
	\end{enumerate}
       
       \item  Положить {$k=k+1$}   
      \end{enumerate}
     
     \item Если {$k \le n$}, то вернуться на шаг 3
     \item Результат: {$\{ b_1,b_2, \dots, b_n \}$}
    \end{enumerate}


\subsection{Теорема Копперсмита}

  \begin{theorem}
   Пусть \textit{N} - целое число, факторизация которого неизвестна и которое имеет делитель {$b \ge N^\beta, 0 < \beta \le 1$}. Пусть {$f(x)$} - одномерный унитарный
   многочлен степени {$\delta$} и {$c \ge 1$}, тогда можно найти все решения {$x_0$} уравнения
   
    \begin{equation}
     \textit{{$ f(x) \equiv 0(mod b), |x_0| \le c N\textsuperscript{{$\frac{\beta^2}{\delta}$}} $}}
    \end{equation}

    за время {$O(c \delta^5 log^9 N)$}
    
    \begin{proof}
     Доказательство приведено в \cite[Глава 8.2, страницы 320-350]{may10}
    \end{proof}

  \end{theorem}
  
  Далее будет представлен алгоритм, на входе которого  
    \begin{itemize}
     \item Целое число {$N$}, факторизация которого не известна
     \item Одномерный инвариантный полином {$f(x)$} степени {$\delta$}
     \item Ограничение {$\beta \in (0,1]$} такое, что {$b \ge N^\beta$} для некотрого делителя {$b$}числа {$N$}
    \end{itemize}
  на выходе
    \begin{itemize}
     \item {$f(x_0) \equiv 0 (mod b)$}
     \item {$|x_0| \le N\textsuperscript{{$\frac{\beta^2}{\delta}$}}$}
    \end{itemize}
    
  Теорема Ховергрэва-Грэхема дает 2 критерия, по которым можно найти полиномы {$g(x)$}, которые эквивалентны нуля при малых значениях целых корней

  \begin{theorem}
   Пусть {$g(x)$} унитарный полином, состоящий из {$n$} мономов, {$m$} - положительное целое число. Тогда если
   
    \begin{enumerate}
     \item {$g(x_0) = 0(mod b^m), |x_0| \le X$}
     \item {$ \lVert g(x X) \lVert < \frac{b^m}{\sqrt{n}} $}
    \end{enumerate}
    
    то, {$g(x_0) = 0$} выполняется для целых чисел.
    
    \begin{proof}
      Доказательство приведено в \cite[Глава 8.2, страницы 321-322]{may10}
    \end{proof}

  \end{theorem}

  \begin{theorem}[Копперсмита]
    Пусть {$N$} - целое число, факторизация которого не известна и делитель {$b \ge N^\beta, 0 < \beta \le 1$}. Пусть {$0 < \epsilon \le \frac{1}{7}\beta$}.
    Кроме того, пусть {$f(x)$} - унитарный одномерный полином степени {$\delta$}. Тогда мы можем найти все решения {$x_0$} уравнения
    
      \begin{equation}
       \textit{{$ f(x) = 0 (mod b), |x_0| \le \frac{1}{2} N\textsuperscript{{$\frac{\beta^2}{\delta} - \epsilon$}} $}}.
      \end{equation}

    Скорость работы алгоритма составляет {$O(\epsilon\textsuperscript{-7} \delta^5 log^2 N)$}
    
    \begin{proof}
      Доказательство приведено в \cite[Глава 8.2, страницы 323-326]{may10}
    \end{proof}

  \end{theorem}

  \subsubsection{Алгоритм Копперсмита для одномерного случая}
    Вход: полином {$f(x)$} степени {$\delta$}, число {$N$} и его делитель {$b$}, {$b \ge N\beta$}, {$\epsilon \le \frac{1}{7} \beta$} \\
    Выход: множество {$R$}, где {$x_0 \in R$} для {$f(x_0) = 0 (mod b), |x_0| \le X$}
    
    \begin{enumerate}
      \item Вычислить {$m = \lceil \frac{\beta^2}{\delta \epsilon} \rceil$} и {$t = \lfloor \delta m (\frac{1}{\beta} - 1) \rfloor$}
      \item Вычислить полиномы
	\begin{equation}
	  \textit{{$ g\textsubscript{{$i,j$}}(x) = x^j N^i f\textsuperscript{{$m-i$}}(x), i=0, \dots, m-1, j=0, \dots, \delta-1 $}}
	\end{equation}
	
	\begin{equation}
	  \textit{{$ h_i(x) = x^i f^m(x), i = 0, \dots, t-1 $}}
	\end{equation}
	
      \item Вычислить ограничение {$X = \frac{1}{2} \lceil N\textsuperscript{{$\frac{\beta^2}{\delta} - \epsilon$}} \rceil$}. Построить базис {$B$} решетки,
	где векторы базиса являются коэффициентами {$g\textsubscript{{$i,j$}}(x X)$} и {$h_i(x X)$}
      \item Применить \textit{LLL-алгоритм} к базису {$B$} решетки. Пусть {$\nu$} - вектор кратчайшей длинны в \textit{LLL-приведенном} базисе. Вектор {$\nu$}
	является коэффициент-вектором полинома {$g(xX)$}. Построить полином {$g(x)$}.
      \item Найти множество {$R$} решений {$g(x)$} над целыми числами. Для каждого корня {$x_0 \in R$} проверить условие НОД{$(N, f(x_0)) \ge N^\beta$}, 
	если условие не выполняется, то необходимо исключить {$x_0$} из {$R$}
    \end{enumerate}

    