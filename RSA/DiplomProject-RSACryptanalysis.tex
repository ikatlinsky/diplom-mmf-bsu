\section{Криптоанализ RSA}

  \paragraph{} Стойкость RSA основывается на проблеме факторизации больших простых чисел. Действительно, если злоумышленнику удастся разложить
  \textit{N} на делители \textit{p} и \textit{q}, то для него не составит труда вычислить \textit{{$\varphi$}(N)}, а затем определить секретный ключ пользователя. 
  Однако нахождение секретного ключа RSA не эквивалентно проблеме факторизации. Это означает, что \textit{T(RSA) {$\le$} T(факторизации)}, 
  где \textit{T(RSA)} - трудоемкость определения секретного ключа RSA, а \textit{T(факторизации)} - трудоемкость факторизации числа \textit{N}. Тоесть 
  могут быть найдены эффективные алгоритмы определения секретного ключа RSA, причем в то же время проблема факторизации не будет разрешена.
  
  Тремя возможными подходами к криптоанализу алгоритма RSA являются следующие:
  
    \begin{itemize}
     \item Простой перебор. Предполагает проверку всех возможных личных ключей.
     \item Математический анализ. Существует несколько подходов такого рода, но все они по сути эквивалентны нахождению множителей произведения 
     двух простых чисел.
     \item Анализ временных затрат. Опирается на анализ времени выполнения алгоритма дешифрования.
    \end{itemize}
    
  Защита против простого перебора в случае RSA остается той же, что и для всех других криптосистем, – использование большого пространства 
  ключей. С этой точки зрения чем больше битов в \textit{e} и \textit{d}, тем лучше. Однако из-за сложности вычислений как при генерировании 
  ключей, так и при шифровании/дешифровании, чем большим оказывается размер ключа, тем медленнее работает система. В этом разделе для 
  алгоритма RSA мы представ-ляем краткий обзор возможностей его криптоанализа при использовании математического подхода и подхода на основе 
  анализа временных затрат.
  
  Можно выделить следующие три математически различных подхода к криптоанализу RSA:
  
    \begin{itemize}
     \item Разложение \textit{N} на два его простых множителя. Это позволит вычислить \textit{{$\varphi$}(N) = (p - 1)(q - 1)}, на основании чего можно будет 
     определить \textit{{$d = e^-1(mod \varphi(N))$}}.
     \item Определение непосредственно \textit{{$\varphi$}(N)} без того, чтобы сначала определять \textit{p} и \textit{q}. Это также позволит
     определить \textit{{$d = e^-1(mod \varphi(N))$}}.
     \item Определение непосредственно \textit{d} без того, чтобы сначала определять \textit{{$\varphi$}(N)}.
    \end{itemize}
    
  В большинстве случаев обсуждение вопросов криптоанализа шифра RSA касается задачи разложения значения \textit{N} на два его простых множителя. 
  Задача определения \textit{{$\varphi$}(N)} по данному \textit{N} оказывается эквивалентной задаче разложения \textit{N} на множители. Для известных сегодня алгоритмов 
  проблема определения \textit{d} по данным \textit{e} и \textit{N} оказывается требующей по крайней мере таких же затрат времени, как и проблема разложения на 
  множители. Следовательно, затраты на решение задачи разложения на множители можно использовать в качестве эталона при оценке степени 
  защищенности RSA.

\subsubsection{Малая экспонента e}

  \paragraph{} Рассмотрим ситуацию, когда у нас имеется малая экспонента \textit{e} (\textit{e = 3,5,7} и т.д.). Пусть \textit{e = 3}. Допустим, что некто
  \textit{А} желает послать одно и то же сообщение трем другим абонентам, имеющим открытые ключи \textit{{$(3, n_1), (3, n_2), (3, n_3)$}}. А шифрует 
  сообщение и получает \textit{{$c_i = m^3(mod N_i)$}} для \textit{i = 1, 2, 3}. Противник перехватывает все 3 сообщения и составляет систему:
  
    \begin{equation}
	\begin{cases}
	   x &= c_1(mod N_1) \\
	   x &= c_2(mod N_2)\\
	   x &= c_3(mod N_3)
	\end{cases}    
    \end{equation}

  Поскольку \textit{{$0 \le x < N_1 N_2 N_3$}} и \textit{{$m^3 < N_1 N_2 N_3$}}, то по китайской теореме об остатках злоумышленник может найти 
  \textit{{$x = m^3$}} и вычислив кубический корень из \textit{x} найдет \textit{m}. Таким образом получаем, что нельзя использовать малые экспоненты 
  при отправке большого числа одинаковых сообщений. Или же следует использовать добавки в сообщение, в качестве которых могут выступать добавленные в 
  конец сообщения случайные вектора или же время отправки. При использовании малых экспонент также возникает проблема с маленькими сообщениями, то есть 
  с такими, для которых \textit{m < n\textsuperscript{{$\frac{1}{e}$}}}, поскольку в этом случае m может быть получено из шифротекста 
  \textit{{$c = m^e(mod N)$}} путем вычисления корня \textit{e-ой} степени из \textit{c}. Однако использование добавок в сообщение помогает избежать этой 
  проблемы.

\subsubsection{Перебор возможных открытых текстов}

  \paragraph{} Если сообщение не велико, злоумышленник может попытаться подобрать открытый текст путем перебора всех возможных вариантов и 
  шифрования их на открытом ключе абонента \textit{e} до тех пор, пока не будет получен перехваченный шифротекст \textit{c}. Такую атаку также возможно 
  предотвратить при помощи добавок в сообщение

\subsubsection{Использование общих модулей}

  \paragraph{} Схема RSA несостоятельна при использовании общих модулей. Допустим есть 2 абонента \textit{A} и \textit{В} с открытыми ключами 
  \textit{(e\textsubscript{1}, N)} и \textit{(e\textsubscript{2}, N)}. Центр (общий сервер или циркуляр) желает послать обоим абонентам одинаковые сообщения. 
  Он получает \textit{{$m_1\textsuperscript{{$e_1$}} = c_1(mod N)$}} и \textit{{$m_2\textsuperscript{{$e_2$}} = c_2(mod N)$}} и посылает \textit{{$c_1$}} и 
  \textit{{$c_2$}} \textit{А} и \textit{В} соответственно. Противник перехватывает эти сообщения. Затем, если \textit{{$(e_1, e_2) = 1$}}, по 
  расширенному алгоритму Евклида можно найти такие \textit{{$k_1$}} и \textit{{$k_2$}}, для которых \textit{{$e_1 k_1 + e_2 k_2 = 1$}}. И, соответственно, 
  \textit{{$m_1^e k_1 m_2^e k_2 = m$}}. Таким образом найдя такие \textit{{$k_1$}} и \textit{{$k_2$}} противник вычислит 
  \textit{{$c_1\textsuperscript{{$k_1$}} c_2\textsuperscript{{$k_2$}} = m$}}.

\subsubsection{Мультипликативные свойства}

  \paragraph{} Система RSA обладает мультипликативными свойствами. Пусть \textit{{$m_1$}} и \textit{{$m_2$}} - 2 различных открытых текста, а \textit{{$c_1$}}
  и \textit{{$c_2$}} - соответствующие им шифротексты. Заметим, что
  
    \begin{equation}
      \textit{{$(m_1 m_2)^e = m_1^e m_2^e = c_1 c_2 (mod N)$}}
    \end{equation}

  Другими словами, шифротекст открытого текста \textit{{$m = m_1 m_2$}} есть \textit{{$c = c_1 c_2 (mod N)$}}. Это свойство, называемое также гомоморфным 
  свойством  RSA, позволяет осуществить атаку по выбранному шифротексту. Его нужно учитывать при совмещении схем шифрования на основе RSA и цифровой подписи
  RSA.

\subsection{LLL-алгоритм}

\paragraph{}

\subsection{Теорема Копперсмита}

\paragraph{}