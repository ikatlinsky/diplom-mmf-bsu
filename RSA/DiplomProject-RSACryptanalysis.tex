% !TEX root = ../DiplomProject.tex

\section{Основные подходы к криптоанализу RSA}

  \paragraph{} Стойкость RSA основывается на проблеме факторизации больших простых чисел, поскольку если удастся разложить
  $N$ на делители $p$ и $q$, то сразу станет возможным вычислить сначала $\varphi(N)$, а затем и секретный ключ. 
  В тоже время найти секретный ключ RSA не эквивалентно решению проблемы факторизации. Это означает, что трудоемкость определения секретного ключа RSA $\le$ трудоемкости факторизации числа $N$. То есть могут быть найдены эффективные алгоритмы определения секретного ключа RSA без решения проблемы факторизации.
  
  Тремя возможными подходами к криптоанализу алгоритма RSA являются простой перебор - предполагает проверку всех возможных личных ключей, математический подход - существует несколько подходов такого рода, но все они по сути эквивалентны нахождению множителей произведения, анализ временных затрат - опирается на анализ времени выполнения алгоритма дешифрования двух простых чисел.
    
  Защитой против простого перебора является использование большого пространства ключей, то есть чем больше битов в $e$ и $d$, тем лучше. Но чем больше эти числа, тем медленнее работает шифр RSA из-за сложности вычислений как при генерировании ключей, так и при шифровании/дешифровании. Таким образом чем большим оказывается размер ключа, тем медленнее работает система. В этой работе мы будем рассматривать математические подходы к криптоанализу шифра RSA.
  
  Можно выделить следующие три математически различных подхода к криптоанализу RSA:
  
    \begin{itemize}
     \item Разложение $N$ на два его простых множителя. Это позволит вычислить $\varphi(N) = (p - 1)(q - 1)$, на основании чего можно будет 
     определить $d = e^{-1}(mod \: \varphi(N))$.
     \item Определение непосредственно $\varphi(N)$ без того, чтобы сначала определять $p$ и $q$. Это также позволит
     определить $d = e^{-1}(mod \: \varphi(N))$.
     \item Определение непосредственно $d$ без того, чтобы сначала определять $\varphi(N)$.
    \end{itemize}
    
  Исходя из перечисленных математических подходов к криптоанализу RSA, криптоанализ шифра RSA касается задачи разложения значения $N$ на два его простых множителя. 
  Задача определения $\varphi(N)$ по данному $N$ эквивалентна задаче разложения $N$ на множители. Для известных сегодня алгоритмов
  проблема определения $d$ по данным $e$ и $N$ оказывается требующей по крайней мере таких же затрат времени, как и проблема разложения на 
  множители. Значит можно считать, что затраты на решение задачи факторизации можно использовать в качестве оценки степени защищенности RSA, а значит их можно использовать 
  при криптоанализе и стойкости шифра RSA.

  Далее будут представлены атаки, которые можно использовать при наличии определенных уязвимостей в шифре RSA. 

\subsubsection{Малая экспонента $e$}

  \paragraph{} Рассмотрим ситуацию, когда у нас имеется малая экспонента $e$ ($e = 3,5,7$ и так далее). Пусть $e=3$. Допустим, что некто
  $A$ желает послать одно и то же сообщение трем другим абонентам, имеющим открытые ключи $(3, n_1)$, $(3, n_2)$, $(3, n_3)$. $A$ шифрует 
  сообщение и получает $c_i = m^3(mod \: N_i)$ для $i = 1, 2, 3$. Противник перехватывает все 3 сообщения и составляет систему:
  
    \begin{equation}
    	\begin{cases}
    	   x = c_1(mod \: N_1) \\
    	   x = c_2(mod \: N_2) \\
    	   x = c_3(mod \: N_3)
    	\end{cases}    
    \end{equation}

  Поскольку $0 \le x < N_1 N_2 N_3$ и $m^3 < N_1 N_2 N_3$, то по китайской теореме об остатках злоумышленник может найти 
  $x = m^3$ и вычислив кубический корень из $x$ найдет $m$. Таким образом получаем, что нельзя использовать малые экспоненты 
  при отправке большого числа одинаковых сообщений. Или же следует использовать добавки в сообщение, в качестве которых могут выступать добавленные в 
  конец сообщения случайные вектора или же время отправки. При использовании малых экспонент также возникает проблема с маленькими сообщениями, то есть 
  с такими, для которых $m < n^{\frac{1}{e}}$, поскольку в этом случае $m$ может быть получено из шифротекста 
  $c = m^e(mod \: N)$ путем вычисления корня $e$-ой степени из $c$. Однако использование добавок в сообщение помогает избежать этой 
  проблемы.

\subsubsection{Перебор возможных открытых текстов}

  \paragraph{} Если сообщение не велико или часто осуществляется отправка идентичных сообщений (в таком случае шифр будет совпадать), то злоумышленник может попытаться подобрать открытый текст путем перебора всех возможных вариантов и шифрования их на открытом ключе абонента $e$ до тех пор, пока не будет получен перехваченный 
  шифротекст $c$. Такую атаку также возможно предотвратить при помощи добавок в сообщение.

\subsubsection{Использование общих модулей}

  \paragraph{} Шифр RSA не рекомендуется использовать с общими модулями, в таком случае система  становится несостоятельной. Допустим есть 2 абонента $A$ и $B$ с 
  открытыми ключами $(e_{1}, N)$ и $(e_{2}, N)$. Сервер желает послать обоим абонентам одинаковые сообщения. 
  Он получает $m_1^{e_1} = c_1(mod \: N)$ и $m_2^{e_2} = c_2(mod \: N)$ и посылает $c_1$ и 
  $c_2$ $A$ и $B$ соответственно. Противник перехватывает эти сообщения. Затем, если $(e_1, e_2) = 1$, по 
  расширенному алгоритму Евклида можно найти такие $k_1$ и $k_2$, для которых $e_1 k_1 + e_2 k_2 = 1$. И, соответственно, 
  $m_1^{e_1 k_1} m_2^{e_2 k_2} = m$. Таким образом найдя такие $k_1$ и $k_2$ противник вычислит $c_1^{k_1} c_2^{k_2} = m$.

\subsubsection{Мультипликативные свойства}

  \paragraph{} Пусть $m_1$ и $m_2$ - 2 различных открытых текста, а $c_1$
  и $c_2$ - соответствующие им шифротексты. Заметим, что
  
    \begin{equation}
      (m_1 m_2)^e = m_1^e m_2^e = c_1 c_2 (mod \: N).
    \end{equation}

  Другими словами, шифротекст открытого текста $m = m_1 m_2$ есть \\ $c = c_1 c_2 (mod \: N)$. Это свойство, называемое также гомоморфным 
  свойством  RSA, позволяет осуществить атаку по выбранному шифротексту. Его нужно учитывать при совмещении схем шифрования на основе RSA и цифровой подписи
  RSA.

\subsection{LLL-алгоритм}

  \begin{definition}
    Пусть векторы $ b_1, b_2, \dots, b_n \in R^m$ линейно независимы, $n < m$. Множество 
      \begin{equation}
	       L=L(b_1, b_2, \dots, b_n) = Zb_1 + Zb_2 + \dots + Zb_n
      \end{equation}    
    всех целочисленных комбинаций векторов $ b_1, b_2, \dots, b_n$ называется решеткой размерности $n$. Множество
    $ \{b_1, b_2, \dots, b_n \} $ называется базисом решетки $L$.
  \end{definition}
  
  \begin{theorem}
    Пусть {$[b_1, b_2, \dots, b_n]$} - матрица, столбцами которой являются линейно независимые векторы {$ b_1, b_2, \dots, b_n \in R^n$}, {$n \le m$}.
    Векторы $ d_1, d_2, \dots, dn \in R^n$ образуют базис решетки {$L(b_1, b_2, \dots, b_n)$} тогда и только тогда, когда существует такая матрица
    {$M$} размера {$n \times n$} с целыми элементами, {$detM = \pm 1$}, что
    
      \begin{equation}
        [d_1, d_2, \dots, d_n]^T = M [b_1, b_2, \dots, b_n]^T
      \end{equation}

      \begin{proof}
        Доказательство приведено в \cite[Глава 8.2, страница 260]{mah06}
      \end{proof}
  \end{theorem}  

  \begin{definition}
   Определителем решетки {$L(b_1,b_2, \dots, b_n) \in R^n$} называется число
   
   \begin{equation}
    d(L) = \sqrt{detB}, B\textsubscript{ij} = (b_i, b_j).
   \end{equation}
   Из равенства для скалярного произведения векторов {$(u, v) = u^T E v$}, где $E$ - единичная матрица, получаем 
   $d(L) = \sqrt{det(B^TEB)} = \sqrt{det(B^TB)}$, где {$B = [b_1,b_2, \dots, b_n]$}.
  \end{definition}
  
  \begin{theorem}
   Определитель решетки не зависит от выбора базиса, то есть является инвариантом решетки.
   
   \begin{proof}
    Доказательство приведено в \cite[Глава 8.2, страница 261]{mah06}
  \end{proof}
  \end{theorem}  
  
  Пусть {$\{ b_1, b_2, \dots, b_n \}$} - базис решетки {$L \subset R^m$}  пусть числа {$\mu\textsubscript{ij}$}, {$1 \le j < i \le n$}, и векторы
  {$\{b_1^*, b_2^*, \dots, b_n^*\}$} получены в результате процесса ортогонализации Грама-Шмидта.
  
  \begin{definition}
   Базис {$\{b_1, b_2, \dots, b_n\}$} называется \textit{LLL-приведенным (приведенным по Ловашу)}, если для соответствующего ортогонализованного базиса
   {$\{b_1^*, b_2^*, \dots, b_n^*\}$} выполнены условия
    \begin{equation}
      \lVert \mu_{kl} \lVert \le \frac{1}{2}, 1 \le l < k \le n
    \end{equation}
   
   \begin{equation}
      \lVert b_i^* \lVert^2 \ge (\frac{3}{4} - \mu\textsubscript{{$i,i-1$}}^2)\lVert b^*\textsubscript{{$i-1$}} \lVert^2, 1<i \le m.
   \end{equation}

  \end{definition}
  
  \begin{lemma}
   Если {$\{b_1, b_2, \dots, b_n\}$} - \textit{LLL-приведенный} базис решетки {$L \subset R^m$}, то для всех {$1 \le j < i \le n$} выполняется неравенство
   
   \begin{equation}
    \lVert b_j^* \lVert^2 \le 2\textsuperscript{{$i-j$}} \lVert b_i^* \lVert^2.
   \end{equation}
   \begin{proof}
      Доказательство приведено в \cite[Глава 8.2, страница 265]{mah06}
   \end{proof}   
  \end{lemma}
  
  \begin{theorem}
   Для \textit{LLL-приведенного} базиса {$\{ b_1, b_2, \dots, b_n \}$} решетки {$L \subset R^m$} справедливы следующие утверждения
   
   \begin{enumerate}
    \item $ \lVert b_i^* \lVert^2 \le 2^{j-1} \lVert b_j^* \lVert^2, 1 \le i < j \le n  $.
    \item $ d(L) \le \prod_{i=0}^{n}{ \lVert b_i \lVert } \le 2^{\frac{n(n-1)}{4}} d(L) $.
    \item $ \lVert b_i \lVert^2 \le 2^{\frac{n-1}{4}} \sqrt[n]{d(L)} $.
   \end{enumerate}

   \begin{proof}
      Доказательство приведено в \cite[Глава 8.2, страница 266]{mah06}
   \end{proof}

  \end{theorem}
  
  \subsubsection{Алгоритм Ленстры-Ленстры-Ловаша - \cite[Глава 8, страницы 256-273]{mah06}}
    Вход: Базис {$\{ b_1,b_2, \dots, b_n \}$} решетки в {$R^m$}, {$m \ge n$}. \\
    Выход: \textit{LLL-приведенный} базис решетки.
  
    \begin{enumerate}
     \item Выполнить процесс ортогонализации Грама-Шмидта для векторов  \\{$b_1, b_2, \dots, b_n$}. 
     \item Положить {$k=2$}.
     \item При {$ |\mu\textsubscript{{$k,k-1$}}| > \frac{1}{2}$} выполнить следующие действия
     
      \begin{enumerate}
       \item При {$ \mu\textsubscript{{$k,k-1$}} > 0 $} вычислить {$r=[\frac{1}{2} + \mu\textsubscript{{$k,k-1$}}]$}, иначе {$r=-[\frac{1}{2} - \mu\textsubscript{{$k,k-1$}}]$}.
       \item Положить {$b_k = b_k - r b\textsubscript{{$k-1$}}$}.
       \item Для {$j=1,2,\dots,k-2$} вычислить {$ \mu\textsubscript{{$k,j$}}=\mu\textsubscript{{$k,j$}} - r \mu\textsubscript{{$k-1,j$}} $}.
       \item Положить {$ \mu\textsubscript{{$k,k-1$}}=\mu\textsubscript{{$k,k-1$}} - r $}.
      \end{enumerate}
     
     \item При {$ B_k < (\frac{3}{4} - \mu^2\textsubscript{{$k,k-1$}})B\textsubscript{{$k-1$}} $} выполнить
     
      \begin{enumerate}
       \item Положить {$\mu = \mu\textsubscript{{$k,k-1$}}$}, {$B=B_k + \mu^2 B\textsubscript{{$k-1$}}$}, {$\mu\textsubscript{{$k,k-1$}}=\frac{\mu B\textsubscript{{$k-1$}}}{B}$},
	{$B_k = \frac{B\textsubscript{{$k-1$}} B_k}{B}$}, {$B\textsubscript{{$k-1$}} = B_k$}.
       \item Поменять местами векторы {$b_k$} и {$b\textsubscript{{$k-1$}}$}.
       \item При {$k > 2$} поменять местами коэффициенты {$\mu\textsubscript{{$k,j$}}$} и {$\mu\textsubscript{{$k-1,j$}}$} для {$j=1,2,\dots,k-2$}.
       \item Для {$s=k+1,k+2,\dots,n$} положить {$t=\mu\textsubscript{{$s,k$}}$}, {$\mu\textsubscript{{$s,k$}}=\mu\textsubscript{{$s,k-1$}}-\mu t$},
	{$\mu\textsubscript{{$s,k-1$}}=t + \mu\textsubscript{{$k,k-1$}} \mu\textsubscript{{$s,k$}}$}.
       \item Положить {$k = max(2,k-1)$} и вернуться на шаг 3.
      \end{enumerate}
     
     \item При {$ B_k \ge (\frac{3}{4} - \mu^2\textsubscript{{$k,k-1$}})B\textsubscript{{$k-1$}} $} выполнить
     
      \begin{enumerate}
       \item Для {$l=k-2,k-3,\dots,1$} при {$\mu\textsubscript{{$k,j$}}$} выполнить
       
	\begin{enumerate}
	  \item При {$ \mu\textsubscript{{$k,l$}} > 0 $} вычислить {$r=[\frac{1}{2} + \mu\textsubscript{{$k,l$}}]$}, иначе {$r=-[\frac{1}{2} - \mu\textsubscript{{$k,l$}}]$}.
	  \item Положить {$b_k=b_k - r b_l$}   .
	  \item Для {$j = 1, 2, \dots, l - 1$} положить {$\mu\textsubscript{{$k,j$}} = \mu\textsubscript{{$k,j$}} - r \mu\textsubscript{{$l,j$}}$}.
	  \item Положить {$\mu\textsubscript{{$k,j$}} = \mu\textsubscript{{$k,l$}} - r$}.
	\end{enumerate}
       
       \item  Положить {$k=k+1$}.   
      \end{enumerate}
     
     \item Если {$k \le n$}, то вернуться на шаг 3.
     \item Результат: {$\{ b_1,b_2, \dots, b_n \}$}.
    \end{enumerate}


\subsection{Теорема Копперсмита}
  \paragraph{} Предположим, что для шифра RSA злоумышленник узнал какое-то число битов секретного ключа. Необходимо выяснить, сможет ли злоумышленник, опираясь на известные ему биты восстановить секретный ключ, иными словами приведет ли частичное раскрытие ключа к полному взлому шифра. Для того, чтобы разобраться в этом вопросе рассмотрим теорему Копперсмита, а также ряд ее приложений, которые покажут, что полный взлом при частичном раскрытии возможен.

  \begin{definition}
    Многочлен одной переменной называется унитарным или приведённым, если его старший коэффициент равен единице.
  \end{definition}

  \begin{theorem}
   Пусть $N$ - целое число, факторизация которого неизвестна и которое имеет делитель {$b \ge N^\beta, 0 < \beta \le 1$}. Пусть {$f(x)$} - 
   унитарный многочлен от одной переменной степени {$\delta$} и {$c \ge 1$}, тогда можно найти все решения {$x_0$} уравнения
   
    \begin{equation}
      f(x) \equiv 0(mod \: b), |x_0| \le c N^{\frac{\beta^2}{\delta}}
    \end{equation}

    за время {$O(c \delta^5 log^9 N)$}.
    
    \begin{proof}
     Доказательство приведено в \cite[страницы 320-350]{may10}
    \end{proof}

  \end{theorem}
  
  Далее будет представлен алгоритм, на входе которого дано
    \begin{itemize}
     \item Целое число {$N$}, факторизация которого не известна,
     \item Унитарный полином от одной переменной {$f(x)$} степени {$\delta$},
     \item Ограничение {$\beta \in (0,1]$} такое, что {$b \ge N^\beta$} для некотрого делителя {$b$} числа {$N$}.
    \end{itemize}

    На выходе за полиномиальное время $\log{N}$ - все решения $x_0$ уравнения {$f(x_0) \equiv 0 (mod \: b)$}, удовлетворяющие условию
    {$|x_0| \le N^{\frac{\beta^2}{\delta}}$}.  
    
  Теорема Ховергрэва-Грэхема дает 2 критерия, по которым можно найти полиномы {$g(x)$} такие, что существуют решения $x_0$ уравнения $g(x_0)=0$

  \begin{theorem}
   Пусть {$g(x)$} унитарный полином, состоящий из {$n$} мономов, {$m$} - положительное целое число. Тогда если
   
    \begin{enumerate}
     \item {$g(x_0) = 0(mod \: b^m), |x_0| \le X$},
     \item {$ \lVert g(x X) \lVert < \frac{b^m}{\sqrt{n}} $},
    \end{enumerate}
    
    то {$g(x_0) = 0$} выполняется для целых чисел $x_0$.
    
    \begin{proof}
      Доказательство приведено в \cite[страницы 321-322]{may10}.
    \end{proof}

  \end{theorem}

  \begin{theorem}[Копперсмита] \label{th:commpersmith}
    Пусть {$N$} - целое число, факторизация которого не известна и делитель {$b \ge N^\beta, 0 < \beta \le 1$}. Пусть {$0 < \epsilon \le \frac{1}{7}\beta$}.
    Кроме того, пусть {$f(x)$} - унитарный одномерный полином степени {$\delta$}. Тогда мы можем найти все решения {$x_0$} уравнения
    
      \begin{equation}
        f(x) = 0 (mod b), |x_0| \le \frac{1}{2} N^{\frac{\beta^2}{\delta} - \epsilon}.
      \end{equation}

    Скорость работы алгоритма составляет {$O(\epsilon^{-7} \delta^5 log^2 N)$}.
    
    \begin{proof}
      Доказательство приведено в \cite[страницы 323-326]{may10}.
    \end{proof}

  \end{theorem}

    Кроме того, можно рассмотреть особый случай \textit{алгоритма Копперсмита} при котором $b=N$ и $c=1$.

  \begin{theorem}
    Пусть {$N$} - целое число, факторизация которого не известна, кроме того, пусть {$f(x)$} - унитарный одномерный полином степени {$\delta$}. Тогда 
    мы можем найти все решения {$x_0$} уравнения

      \begin{equation}
        f(x) = 0 (mod b), |x_0| \le N^{\frac{1}{\delta}}.
      \end{equation}

    Скорость работы алгоритма составляет {$O(\delta^5 log^9 N)$}.
    \begin{proof}
      Доказательство приведено в \cite[страницы 326-327]{may10}.
    \end{proof}
  \end{theorem}

  \subsubsection{Алгоритм Копперсмита для одномерного случая - \cite[страницы 321-327]{may10}}
    Вход: полином {$f(x)$} степени {$\delta$}, число {$N$}. \\
    Выход: множество {$R$} решений таких, что {$x_0 \in R$} для {$f(x_0) = 0 (mod \: b), |x_0| \le X$}.
    
    \begin{enumerate}
      \item Вычислить {$m = \lceil \frac{\beta^2}{\delta \epsilon} \rceil$} и {$t = \lfloor \delta m (\frac{1}{\beta} - 1) \rfloor$}.
      \item Вычислить полиномы
	\begin{equation}
	   g\textsubscript{{$i,j$}}(x) = x^j N^i f^{m-i}(x), i=0, \dots, m-1, j=0, \dots, \delta-1,
	\end{equation}
	
	\begin{equation}
	   h_i(x) = x^i f^m(x), i = 0, \dots, t-1.
	\end{equation}
	
      \item Вычислить ограничение {$X = \frac{1}{2} \lceil N^{\frac{\beta^2}{\delta} - \epsilon} \rceil$}. Построить базис {$B$} решетки,
	где векторы базиса являются коэффициентами {$g\textsubscript{{$i,j$}}(x X)$} и {$h_i(x X)$}.
      \item Применить \textit{LLL-алгоритм} к базису {$B$} решетки. Пусть {$\nu$} - вектор кратчайшей длинны в \textit{LLL-приведенном} базисе. Вектор {$\nu$} - коэффициент-вектор полинома {$g(xX)$}. Построить полином {$g(x)$}.
      \item Найти множество {$R$} целых решений {$g(x) = 0$}. Для каждого корня {$x_0 \in R$} проверить условие НОД{$(N, f(x_0)) \ge N^\beta$}
      , если условие не выполняется, то необходимо исключить {$x_0$} из {$R$}.
    \end{enumerate}    