\section{Основы RSA}

\subsection{Теория}

\paragraph{} Пусть \textit{n} и \textit{e} натуральные числа. Функция \textit{f} реализующая схему RSA, устроена следующим образом
\begin{equation}
  \textit{f : x {$\rightarrow$} x\textsuperscript{e} (mod n)},
\end{equation}
Для расшифровки сообщения \textit{a = f(x)} достаточно решить сравнение 

\begin{equation}
  \textit{x\textsuperscript{e} = a (mod n)} 
\end{equation}
При некоторых условиях на \textit{n} и \textit{e} это сравнение имеет единственное решение \textit{x}.

  Для того, чтобы описать эти условия и объяснить, как можно найти решение, нам потребуется одна теоретико-числовая функция - функция Эйлера. 
Эта функция натурального аргумента \textit{n} обозначается \textit{{$\varphi$}(n)} и равняется количеству целых чисел на отрезке от 1 до \textit{n}, 
взаимно простых с \textit{n}. Так \textit{{$\varphi$}(1) = 1} и \textit{{$\varphi$}(p\textsuperscript{r}) = p\textsuperscript{r-1}(p-1)} 
для любого простого числа \textit{p} и натурального \textit{r}. Кроме того, \textit{{$\varphi$}(a b) = {$\varphi$}(b) {$\varphi$}(a)} 
для любых натуральных взаимно простых \textit{a} и \textit{b}. Эти свойства позволяют легко вычислить значение \textit{{$\varphi$}(n)}, если известно 
разложение числа \textit{n} на простые сомножители. 

  Если показатель степени \textit{e} в сравнении (3.2) взаимно прост с \textit{{$\varphi$}(n)}, то сравнение (3.2) имеет единственное решение. 
Для того, чтобы найти его, определим целое число \textit{d}, удовлетворяющее условиям. 
\begin{equation}
 \textit{d e {$\equiv$} (mod {$\varphi$}(n)), 1 {$\leq$} d {$<$} {$\varphi$}}.
\end{equation}
Такое число существует, поскольку \textit{(e, {$\varphi$}(n)) = 1}, и притом единственно. Здесь и далее символом \textit{(a, b)} будет обозначаться 
наибольший общий делитель чисел \textit{a} и \textit{b}. Классическая теорема Эйлера, утверждает, что для каждого числа \textit{x}, взаимно простого 
с \textit{n}, выполняется сравнение \textit{x\textsuperscript{ {$\varphi$}(n)} {$\equiv$} 1 (mod n) } и, следовательно
\begin{equation}
 \textit{a\textsuperscript{ d} {$\equiv$} x\textsuperscript{ d e} {$\equiv$} x (mod n)}.
\end{equation}
Таким образом, в предположении \textit{(a, m) = 1}, единственное решение сравнения (3.2) может быть найдено в виде
\begin{equation}
 \textit{x {$\equiv$} a\textsuperscript{ d} (mod n)}.
\end{equation}
Если дополнительно предположить, что число \textit{n} состоит из различных простых сомножителей, то сравнение (3.5) будет выполняться и без 
предположения \textit{(a, m) = 1}. Действительно, обозначим \textit{r = (a, n)} и \textit{s = n/r}. Тогда {$\varphi$}(n) делится на {$\varphi$}(r), 
а из (3.2) следует, что \textit{(x, s) = 1}. Подобно (3.4), теперь легко находим (3.5). А кроме того, имеем \textit{x {$\equiv$} 0 {$\equiv$} a\textsuperscript{ r} (mod r)}. 
Получившиеся сравнения в силу \textit{(r, s) = 1} дают нам (3.5).

  Функция (3.1), принятая в системе RSA, может быть вычислена достаточно быстро. Обратная к \textit{f(x)} функция  вычисляется по тем же правилам, что и , 
лишь с заменой показателя степени  на . Таким образом, для функции (1) будут выполнены указанные выше свойства 1) и 2).
Для вычисления функции (1) достаточно знать лишь числа  и . Именно они составляют открытый ключ для шифрования. А вот для вычисления обратной 
функции требуется знать число . оно и является «скретом», о котором речь идёт в пункте в). Казалось бы. ничего не стоит. зная число . разложить 
его на простые сомножители, вычислить затем с помощью известных правил значение  и, наконец, с помощью (3) определить нужное число . Все шаги 
этого вычисления могут быть реализованы достаточно быстро, за исключением первого. Именно разложение числа  на простые множители и составляет 
наиболее трудоемкую часть вычислений. В теории чисел несмотря на многолетнюю её историю и на очень интенсивные поиски в течение последних 20 лет, 
эффективный алгоритм разложения натуральных чисел на множители так и не найден. Конечно, можно, перебирая все простые числа до , и. деля на них , 
найти требуемое разложение. Но, учитывая, что количество простых в этом промежутке, асимптотически равно , находим, что при , записываемом 100 
десятичными цифрами, найдётся не менее  простых чисел, на которые придётся делить  при разложении его на множители. Очень грубые прикидки показывают, 
что компьютеру, выполняющему миллион делений в секунду, для разложения числа  таким способом на простые сомножители потребуется не менее, чем  лет. 
Известны и более эффективные способы разложения целых чисел на множители, чем простой перебор простых делителей, но и они работают очень медленно.
Авторы схемы RSA предложили выбирать число в виде произведения двух простых множителей  и , примерно одинаковых по величине. Так как то единственное 
условие на выбор показателя степени  в отображении (1) есть. Итак, лицо, заинтересованное в организации шифрованной переписки с помощью схемы RSA, 
выбирает два достаточно больших простых числа  и . Перемножая их, оно находит число . Затем выбирается число , удовлетворяющее условиям (7), 
вычисляется с помощью (6) число  и с помощью (3) - число . Числа  и  публикуются, число  остается секретным. Теперь любой может отправлять зашифрованные 
с помощью (1) сообщения организатору этой системы, а организатор легко сможет расшифровывать их с помощью (5).
Для иллюстрации своего метода Ривест, Шамир и Адлеман зашифровали таким способом некоторую английскую фразу. Сначала она стандартным образом (а=01, b=02, .... z=26, пробел=00) 
была записана в виде целого числа , а затем зашифрована с помощью отображения (1) при
m=11438162575788886766932577997614661201021829672124236256256184293570 6935245733897830597123563958705058989075147599290026879543541
и . Эти два числа были опубликованы, причем дополнительно сообщалось, что . где  и  - простые числа, записываемые соответственно 64 и 65 десятичными 
знаками. Первому, кто расшифрует соответствующее сообщение
,
была обещана награда в 100\$.
Эта история завершилась спустя 17 лет в 1994 г., когда D. Atkins, M. Graff, А. К. Lenstra и Р. С. Leyland сообщили о расшифровке фразы. Числа  и  
оказались равными

Этот замечательный результат (разложение на множители 129-значного десятичного числа) был достигнут благодаря использованию алгоритма разложения чисел 
на множители, называемого методом квадратичного решета. Выполнение вычислений потребовало колоссальных ресурсов. В работе, возглавлявшейся четырьмя 
авторами проекта, и продолжавшейся после предварительной теоретической подготовки примерно 220 дней, на добровольных началах участвовало около 600 
человек и примерно 1600 компьютеров, объединённых сетью Internet. Наконец, отметим, что премия в 100\$ была передана в Free Software Foundation.
 	2.2.Сложность теоретико-числовых алгоритмов
Сложность алгоритмов теории чисел обычно принято измерять количеством арифметических операций (сложений, вычитаний, умножений и делений с остатком), 
необходимых для выполнения всех действий, предписанных алгоритмом. Впрочем, это определение не учитывает величины чисел, участвующих в вычислениях. 
Ясно, что перемножить два стозначных числа значительно сложнее, чем два однозначных, хотя при этом и в том, и в другом случае выполняется лишь одна 
арифметическая операция. Поэтому иногда учитывают ещё и величину чисел, сводя дело к так называемым битовым операциям, т. е. оценивая количество 
необходимых операций с цифрами 0 и 1, в двоичной записи чисел.
Говоря о сложности алгоритмов, мы будем иметь в виду количество арифметических операций. При построении эффективных алгоритмов и обсуждении верхних 
оценок сложности обычно хватает интуитивных понятий той области математики, которой принадлежит алгоритм. Формализация же этих понятий требуется лишь 
тогда, когда речь идёт об отсутствии алгоритма или доказательстве нижних опенок сложности.
Приведем теперь примеры достаточно быстрых алгоритмов с опенками их сложности. Здесь и в дальнейшем мы не будем придерживаться формального описания 
алгоритмов, стараясь в первую очередь объяснить смысл выполняемых действий.

\subsection{Алгоритм создания ключей}

\subsection{Алгоритм шифрования и расшифрования}

\subsection{Примеры}